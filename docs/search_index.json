[["index.html", "Intermediate R Overview", " Intermediate R Nick Ulle 2023-01-19 Overview This is the reader for all of UC Davis DataLab’s Intermediate R workshop series. There are currently two: Thinking in R, which is about understanding how R works, how to diagnose and fix bugs in code, and how to estimate and measure performance characteristics of code. Cleaning Data &amp; Automating Tasks, which is about how to clean and prepare messy data such as dates, times, and text for analysis, and how to use loops or other forms of iteration to automate repetitive tasks. Each series is independent and consists of 2 sessions (equivalently, 2 chapters in this reader). After completing both series, students will have a better understanding of language features, packages, and programming strategies, which will enable them to write more efficient code, be more productive when writing code, and debug code more effectively. These series are not an introduction to R. Participants are expected to have prior experience using R, be comfortable with basic R syntax, and to have it pre-installed and running on their laptops. They are appropriate for motivated intermediate to advanced users who want a better understanding of base R. "],["language-fundamentals.html", "1 Language Fundamentals 1.1 Variables &amp; Environments 1.2 Closures 1.3 Attributes 1.4 S3 1.5 Other Object Systems", " 1 Language Fundamentals This chapter is part 1 (of 2) of Thinking in R, a workshop series about how R works and how to examine code critically. The major topics of this chapter are how R stores and locates variables (including functions) defined in your code and in packages, and how some of R’s object-oriented programming systems work. Learning Objectives Explain what an environment is and how R uses them Explain how R looks up variables Explain what attributes are and how R uses them Get and set attributes Explain what (S3) classes are and how R uses them Explain R’s (S3) method dispatch system Create an (S3) class Describe R’s other object-oriented programming systems at a high level 1.1 Variables &amp; Environments Assigning and looking up values of variables are fundamental operations in R, as in most programming languages. They were likely among the first operations you learned, and now you use them instictively. This section is a deep dive into what R actually does when you assign a variables and how R looks up the values of those variables later. Understanding the process and the data structures involved will introduce you to new programming strategies, make it easier to reason about code, and help you identify potential bugs. 1.1.1 What’s an Environment? The foundation of how R stores and looks up variables is a data structure called an environment. Every environment has two parts: A frame, which is a collection of names and associated R objects. A parent or enclosing environment, which must be another environment. For now, you’ll learn how to create environments and how to assign and get values from their frames. Parent environments will be explained in a later section. You can use the new.env function to create a new environment: e = new.env() e ## &lt;environment: 0x5636f4d2aec0&gt; Unlike most objects, printing an environment doesn’t print its contents. Instead, R prints its type (which is environment) and a unique identifier (0x5636f4d2aec0 in this case). The unique identifier is actually the memory address of the environment. Every object you use in R is stored as a series of bytes in your computer’s random-access memory (RAM). Each byte in memory has a unique address, similar to how each house on a street has a unique address. Memory addresses are usually just numbers counting up from 0, but they’re often written in hexadecimal (base 16) (indicated by the prefix 0x) because it’s more concise. For the purposes of this reader, you can just think of the memory address as a unique identifier. To see the names in an environment’s frame, you can call the ls or names function on the environment: ls(e) ## character(0) names(e) ## character(0) You just created the environment e, so its frame is currently empty. The printout character(0) means R returned a character vector of length 0. You can assign an R object to a name in an environment’s frame with the dollar sign $ operator or the double square bracket [[ operator, similar to how you would assign a named element of a list. For example, one way to assign the number 8 to the name \"lucky\" in the environment e’s frame is: e$lucky = 8 Now there’s a name defined in the environment: ls(e) ## [1] &quot;lucky&quot; names(e) ## [1] &quot;lucky&quot; Here’s another example of assigning an object to a name in the environment: e[[&quot;my_message&quot;]] = &quot;May your coffee kick in before reality does.&quot; You can assign any type of R object to a name in an environment, including other environments. The ls function ignores names that begin with a dot . by default. For example: e$.x = list(1, sin) ls(e) ## [1] &quot;lucky&quot; &quot;my_message&quot; You can pass the argument all.names = TRUE to make the function return all names in the frame: ls(e, all.names = TRUE) ## [1] &quot;.x&quot; &quot;lucky&quot; &quot;my_message&quot; Alternatively, you can just use the names function, which always prints all names in an environment’s frame. Objects in an environment’s frame don’t have positions or any particular order, so they must always be assigned to a name. R raises an error if you try to assign an object to a position: e[[3]] = 10 ## Error in e[[3]] = 10: wrong args for environment subassignment As you might expect, you can also use the dollar sign operator and double square bracket operator to get objects in an environment by name: e$my_message ## [1] &quot;May your coffee kick in before reality does.&quot; e[[&quot;lucky&quot;]] ## [1] 8 You can use the exists function to check whether a specific name exists in an environment’s frame: exists(&quot;hi&quot;, e) ## [1] FALSE exists(&quot;lucky&quot;, e) ## [1] TRUE Finally, you can remove a name and object from an environment’s frame with the rm function. Make sure to pass the environment as the argument to the envir parameter when you do this: rm(&quot;lucky&quot;, envir = e) exists(&quot;lucky&quot;, e) ## [1] FALSE 1.1.2 Reference Objects Environments are reference objects, which means they don’t follow R’s copy-on-write rule: for most types of objects, if you modify the object, R automatically and silently makes a copy, so that any other variables that refer to the object remain unchanged. As an example, lists follow the copy-on-write rule. Suppose you assign a list to variable x, assign x to y, and then make a change to x: x = list() x$a = 10 x ## $a ## [1] 10 y = x x$a = 20 y ## $a ## [1] 10 When you run y = x, R makes y refer to the same object as x, without using any additional memory. When you run x$a = 20, the copy-on-write rule applies, so R creates and modifies a copy of the object. From then on, x refers to the modified copy and y refers to the original. Environments don’t follow the copy-on-write rule, so repeating the example with an enviroment produces a different result: e_x = new.env() e_x$a = 10 e_x$a ## [1] 10 e_y = e_x e_x$a = 20 e_y$a ## [1] 20 As before, e_y = e_x makes both e_y and e_x refer to the same object. The difference is that when you run e_x$a = 20, the copy-on-write rule does not apply and R does not create a copy of the environment. As a result, the change to e_x is also reflected in e_y. Environments and other reference objects can be confusing since they behave differently from most objects. You usually won’t need to construct or manipulate environments directly, but it’s useful to know how to inspect them. 1.1.3 The Local Environment Think of environments as containers for variables. Whenever you assign a variable, R assigns it to the frame of an environment. Whenever you get a variable, R searches through one or more environments for its value. When you start R, R creates a special environment called the global environment to store variables you assign at the prompt or the top level of a script. You can use the globalenv function to get the global environment: g = globalenv() g ## &lt;environment: R_GlobalEnv&gt; The global environment is easy to recognize because its unique identifier is R_GlobalEnv rather than its memory address (even though it’s stored in your computer’s memory like any other object). The local environment is the environment where the assignment operators &lt;- and = assign variables. Think of the local environment as the environment that’s currently active. The local environment varies depending on the context where you run an expression. You can get the local environment with the environment function: loc = environment() loc ## &lt;environment: R_GlobalEnv&gt; As you can see, at the R prompt or the top level of an R script, the local environment is just the global environment. Except for names, the functions introduced in Section 1.1.1 default to the local environment if you don’t set the envir parameter. This makes them convenient for inspecting or modifying the local environment’s frame: ls(loc) ## [1] &quot;e&quot; &quot;e_x&quot; &quot;e_y&quot; &quot;g&quot; &quot;loc&quot; &quot;x&quot; &quot;y&quot; ls() ## [1] &quot;e&quot; &quot;e_x&quot; &quot;e_y&quot; &quot;g&quot; &quot;loc&quot; &quot;x&quot; &quot;y&quot; If you assign a variable, it appears in the local environment’s frame: coffee = &quot;Right. No coffee. This is a terrible planet.&quot; ls() ## [1] &quot;coffee&quot; &quot;e&quot; &quot;e_x&quot; &quot;e_y&quot; &quot;g&quot; &quot;loc&quot; &quot;x&quot; &quot;y&quot; loc$coffee ## [1] &quot;Right. No coffee. This is a terrible planet.&quot; Conversely, if you assign an object in the local environment’s frame, you can access it as a variable: loc$tea = &quot;Tea isn&#39;t coffee!&quot; tea ## [1] &quot;Tea isn&#39;t coffee!&quot; 1.1.4 Call Environments Every time you call (not define) a function, R creates a new environment. R uses this call environment as the local environment while the code in the body of the function runs. As a result, assigning variables in a function doesn’t affect the global environment, and they generally can’t be accessed from outside of the function. For example, consider this function which assigns the variable hello: my_hello = function() { hello = &quot;from the other side&quot; } Even after calling the function, there’s no variable hello in the global environment: my_hello() names(g) ## [1] &quot;loc&quot; &quot;my_hello&quot; &quot;tea&quot; &quot;e_x&quot; &quot;x&quot; &quot;e_y&quot; ## [7] &quot;y&quot; &quot;coffee&quot; &quot;e&quot; &quot;g&quot; &quot;.First&quot; As further demonstration, consider this modified version of my_hello, which returns the call environment: my_hello = function() { hello = &quot;from the other side&quot; environment() } The call environment is not the global environment: e = my_hello() e ## &lt;environment: 0x5636f6f07540&gt; And the variable hello exists in the call environment, but not in the global environment: exists(&quot;hello&quot;, g) ## [1] FALSE exists(&quot;hello&quot;, e) ## [1] TRUE e$hello ## [1] &quot;from the other side&quot; Each call to a function creates a new call environment. So if you call my_hello again, it returns a different environment (pay attention to the memory address): e2 = my_hello() e ## &lt;environment: 0x5636f6f07540&gt; e2 ## &lt;environment: 0x5636f73563f8&gt; By creating a new environment for every call, R isolates code in the function body from code outside of the body. As a result, most R functions have no side effects. This is a good thing, since it means you generally don’t have to worry about calls assigning, reassigning, or removing variables in other environments (such as the global environment!). The local function provides another way to create a new local environment in which to run code. However, it’s usually preferable to define and call a function, since that makes it easier to test and reuse the code. 1.1.5 Lexical Scoping A function can access variables outside of its local environment, but only if those variables exist in the environment where the function was defined (not called). This property is called lexical scoping. For example, assign a variable tea and function get_tea in the global environment: tea = &quot;Tea isn&#39;t coffee!&quot; get_tea = function() { tea } Then the get_tea function can access the tea variable: get_tea() ## [1] &quot;Tea isn&#39;t coffee!&quot; Note that variable lookup takes place when a function is called, not when it’s defined. This is called dynamic lookup. For example, the result from get_tea changes if you change the value of tea: tea = &quot;Tea for two.&quot; get_tea() ## [1] &quot;Tea for two.&quot; tea = &quot;Tea isn&#39;t coffee!&quot; get_tea() ## [1] &quot;Tea isn&#39;t coffee!&quot; When a local variable (a variable in the local environment) and a non-local variable have the same name, R almost always prioritizes the local variable. For instance: get_local_tea = function() { tea = &quot;Earl grey is tea!&quot; tea } get_local_tea() ## [1] &quot;Earl grey is tea!&quot; The function body assigns the local variable tea to \"Earl grey is tea!\", so R returns that value rather than \"Tea isn't coffee!\". In other words, local variables mask, or hide, non-local variables with the same name. There’s only one case where R doesn’t prioritize local variables. To see it, consider this call: mean(1:20) ## [1] 10.5 The variable mean must refer to a function, because it’s being called—it’s followed by parentheses ( ), the call syntax. In this situation, R ignores local variables that aren’t functions, so you can write code such as: mean = 10 mean(1:10) ## [1] 5.5 That said, defining a local variable with the same name as a function can still be confusing, so it’s usually considered a bad practice. To help you reason about lexical scoping, you can get the environment where a function was defined by calling the environment function on the function itself. For example, the get_tea function was defined in the global environment: environment(get_tea) ## &lt;environment: R_GlobalEnv&gt; 1.1.6 Variable Lookup The key to how R looks up variables and how lexical scoping works is that in addition to a frame, every environment has a parent environment. When R evaluates a variable in an expression, it starts by looking for the variable in the local environment’s frame. For example, at the prompt, tea is a local variable because that’s where you assigned it. If you enter tea at the prompt, R finds tea in the local environment’s frame and returns the value: tea ## [1] &quot;Tea isn&#39;t coffee!&quot; On the other hand, in the get_tea function from Section 1.1.5, tea is not a local variable: get_tea = function() { tea } To make this more concrete, consider a function which just returns its call environment: get_call_env = function() { environment() } The call environment clearly doesn’t contain the tea variable: e = get_call_env() ls(e) ## character(0) When a variable doesn’t exist in the local environment’s frame, then R gets the parent environment of the local environment. You can use the parent.env function to get the parent environment of an environment. For the call environment e, the parent environment is the global environment, because that’s where get_call_env was defined: parent.env(e) ## &lt;environment: R_GlobalEnv&gt; When R can’t find tea in the call environment’s frame, R gets the parent environment, which is the global environment. Then R searches for tea in the global environment, finds it, and returns the value. R repeats the lookup process for as many parents as necessary to find the variable, stopping only when it finds the variable or a special environment called the empty environment which will be explained in Section 1.1.7. The lookup process also hints at how R finds variables and functions such as pi and sqrt that clearly aren’t defined in the global environment. They’re defined in parent environments of the global environment. The get function looks up a variable by name: get(&quot;pi&quot;) ## [1] 3.141593 You can use the get function to look up a variable starting from a specific environment or to control how R does the lookup the variable. For example, if you set inherits = FALSE, R will not search any parent environments: get(&quot;pi&quot;, inherits = FALSE) ## Error in get(&quot;pi&quot;, inherits = FALSE): object &#39;pi&#39; not found As with most functions for inspecting and modifying environments, use the get function sparingly. R already provides a much simpler way to get a variable: the variable’s name. 1.1.7 The Search Path R also uses environments to manage packages. Each time you load a package with library or require, R creates a new environment: The frame contains the package’s local variables. The parent environment is the environment of the previous package loaded. This new environment becomes the parent of the global environment. R always loads several built-in packages at startup, which contain variables and functions such as pi and sqrt. Thus the global environment is never the top-level environment. For instance: g = globalenv() e = parent.env(g) e ## &lt;environment: package:stats&gt; ## attr(,&quot;name&quot;) ## [1] &quot;package:stats&quot; ## attr(,&quot;path&quot;) ## [1] &quot;/usr/lib/R/library/stats&quot; e = parent.env(e) e ## &lt;environment: package:graphics&gt; ## attr(,&quot;name&quot;) ## [1] &quot;package:graphics&quot; ## attr(,&quot;path&quot;) ## [1] &quot;/usr/lib/R/library/graphics&quot; Notice that package environments use package: and the name of the package as their unique identifier rather than their memory address. The chain of package environments is called the search path. The search function returns the search path: search() ## [1] &quot;.GlobalEnv&quot; &quot;package:stats&quot; &quot;package:graphics&quot; ## [4] &quot;package:grDevices&quot; &quot;package:utils&quot; &quot;package:datasets&quot; ## [7] &quot;package:methods&quot; &quot;Autoloads&quot; &quot;package:base&quot; The base environment (identified by base) is the always topmost environment. You can use the baseenv function to get the base environment: baseenv() ## &lt;environment: base&gt; The base environment’s parent is the special empty environment (identified by R_EmptyEnv), which contains no variables and has no parent. You can use the emptyenv function to get the empty environment: emptyenv() ## &lt;environment: R_EmptyEnv&gt; Understanding R’s process for looking up variables and the search path is helpful for resolving conflicts between the names of variables in packages. 1.1.7.1 The Colon Operators The double-colon operator :: gets a variable in a specific package. Two common uses: Disambiguate which package you mean when several packages have variables with the same names. Get a variable from a package without loading the package. For example: library(dplyr) ## Registered S3 methods overwritten by &#39;tibble&#39;: ## method from ## format.tbl pillar ## print.tbl pillar ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union stats::filter ## function (x, filter, method = c(&quot;convolution&quot;, &quot;recursive&quot;), ## sides = 2L, circular = FALSE, init = NULL) ## { ## method &lt;- match.arg(method) ## x &lt;- as.ts(x) ## storage.mode(x) &lt;- &quot;double&quot; ## xtsp &lt;- tsp(x) ## n &lt;- as.integer(NROW(x)) ## if (is.na(n)) ## stop(gettextf(&quot;invalid value of %s&quot;, &quot;NROW(x)&quot;), domain = NA) ## nser &lt;- NCOL(x) ## filter &lt;- as.double(filter) ## nfilt &lt;- as.integer(length(filter)) ## if (is.na(nfilt)) ## stop(gettextf(&quot;invalid value of %s&quot;, &quot;length(filter)&quot;), ## domain = NA) ## if (anyNA(filter)) ## stop(&quot;missing values in &#39;filter&#39;&quot;) ## if (method == &quot;convolution&quot;) { ## if (nfilt &gt; n) ## stop(&quot;&#39;filter&#39; is longer than time series&quot;) ## sides &lt;- as.integer(sides) ## if (is.na(sides) || (sides != 1L &amp;&amp; sides != 2L)) ## stop(&quot;argument &#39;sides&#39; must be 1 or 2&quot;) ## circular &lt;- as.logical(circular) ## if (is.na(circular)) ## stop(&quot;&#39;circular&#39; must be logical and not NA&quot;) ## if (is.matrix(x)) { ## y &lt;- matrix(NA, n, nser) ## for (i in seq_len(nser)) y[, i] &lt;- .Call(C_cfilter, ## x[, i], filter, sides, circular) ## } ## else y &lt;- .Call(C_cfilter, x, filter, sides, circular) ## } ## else { ## if (missing(init)) { ## init &lt;- matrix(0, nfilt, nser) ## } ## else { ## ni &lt;- NROW(init) ## if (ni != nfilt) ## stop(&quot;length of &#39;init&#39; must equal length of &#39;filter&#39;&quot;) ## if (NCOL(init) != 1L &amp;&amp; NCOL(init) != nser) { ## stop(sprintf(ngettext(nser, &quot;&#39;init&#39; must have %d column&quot;, ## &quot;&#39;init&#39; must have 1 or %d columns&quot;, domain = &quot;R-stats&quot;), ## nser), domain = NA) ## } ## if (!is.matrix(init)) ## dim(init) &lt;- c(nfilt, nser) ## } ## ind &lt;- seq_len(nfilt) ## if (is.matrix(x)) { ## y &lt;- matrix(NA, n, nser) ## for (i in seq_len(nser)) y[, i] &lt;- .Call(C_rfilter, ## x[, i], filter, c(rev(init[, i]), double(n)))[-ind] ## } ## else y &lt;- .Call(C_rfilter, x, filter, c(rev(init[, 1L]), ## double(n)))[-ind] ## } ## tsp(y) &lt;- xtsp ## class(y) &lt;- if (nser &gt; 1L) ## c(&quot;mts&quot;, &quot;ts&quot;) ## else &quot;ts&quot; ## y ## } ## &lt;bytecode: 0x5636f5b4c188&gt; ## &lt;environment: namespace:stats&gt; dplyr::filter ## function (.data, ..., .preserve = FALSE) ## { ## UseMethod(&quot;filter&quot;) ## } ## &lt;bytecode: 0x5636f5fc6b30&gt; ## &lt;environment: namespace:dplyr&gt; ggplot2::ggplot ## function (data = NULL, mapping = aes(), ..., environment = parent.frame()) ## { ## UseMethod(&quot;ggplot&quot;) ## } ## &lt;bytecode: 0x5636f46dfd68&gt; ## &lt;environment: namespace:ggplot2&gt; The related triple-colon operator ::: gets a private variable in a package. Generally these are private for a reason! Only use ::: if you’re sure you know what you’re doing. 1.2 Closures A closure is a function together with an enclosing environment. In order to support lexical scoping, every R function is a closure (except a few very special built-in functions). The enclosing environment is generally the environment where the function was defined. Recall that you can use the environment function to get the enclosing environment of a function: f = function() 42 environment(f) ## &lt;environment: R_GlobalEnv&gt; Since the enclosing environment exists whether or not you call the function, you can use the enclosing environment to store and share data between calls. You can use the superassignment operator &lt;&lt;- to assign to a variable to an ancestor environment (if the variable already exists) or the global environment (if the variable does not already exist). For example, suppose you want to make a function that returns the number of times it’s been called: counter = 0 count = function() { counter &lt;&lt;- counter + 1 counter } In this example, the enclosing environment is the global environment. Each time you call count, it assigns a new value to the counter variable in the global environment. 1.2.1 Tidy Closures The count function has a side effect—it reassigns a non-local variable. As discussed in 1.1.4, functions with side effects make code harder to understand and reason about. Use side effects sparingly and try to isolate them from the global environment. When side effects aren’t isolated, several things can go wrong. The function might overwrite the user’s variables: counter = 0 count() ## [1] 1 Or the user might overwrite the function’s variables: counter = &quot;hi&quot; count() ## Error in counter + 1: non-numeric argument to binary operator For functions that rely on storing information in their enclosing environment, there are several different ways to make sure the enclosing environment is isolated. Two of these are: Define and return the function from the body of another function. The second function is called a factory function because it produces (returns) the first. The enclosing environment of the first function is the call environment of the second. Define the function inside of a call to local. Here’s a template for the first approach: make_fn = function() { # Define variables in the enclosing environment here: # Define and return the function here: function() { # ... } } f = make_fn() # Now you can call f() as you would any other function. For example, you can use the template for the counter function: make_count = function() { counter = 0 function() { counter &lt;&lt;- counter + 1 counter } } count = make_count() Then calling count has no effect on the global environment: counter = 10 count() ## [1] 1 counter ## [1] 10 1.3 Attributes An attribute is named metadata attached to an R object. Attributes provide basic information about objects and play an important role in R’s class system, so most objects have attributes. Some common attributes are: class – the class row.names – row names names – element names or column names dim – dimensions (on matrices) dimnames – names of dimensions (on matrices) R provides helper functions to get and set the values of the common attributes. These functions usually have the same name as the attribute. For example, the class function gets or sets the class attribute: class(mtcars) ## [1] &quot;data.frame&quot; row.names(mtcars) ## [1] &quot;Mazda RX4&quot; &quot;Mazda RX4 Wag&quot; &quot;Datsun 710&quot; ## [4] &quot;Hornet 4 Drive&quot; &quot;Hornet Sportabout&quot; &quot;Valiant&quot; ## [7] &quot;Duster 360&quot; &quot;Merc 240D&quot; &quot;Merc 230&quot; ## [10] &quot;Merc 280&quot; &quot;Merc 280C&quot; &quot;Merc 450SE&quot; ## [13] &quot;Merc 450SL&quot; &quot;Merc 450SLC&quot; &quot;Cadillac Fleetwood&quot; ## [16] &quot;Lincoln Continental&quot; &quot;Chrysler Imperial&quot; &quot;Fiat 128&quot; ## [19] &quot;Honda Civic&quot; &quot;Toyota Corolla&quot; &quot;Toyota Corona&quot; ## [22] &quot;Dodge Challenger&quot; &quot;AMC Javelin&quot; &quot;Camaro Z28&quot; ## [25] &quot;Pontiac Firebird&quot; &quot;Fiat X1-9&quot; &quot;Porsche 914-2&quot; ## [28] &quot;Lotus Europa&quot; &quot;Ford Pantera L&quot; &quot;Ferrari Dino&quot; ## [31] &quot;Maserati Bora&quot; &quot;Volvo 142E&quot; An attribute can have any name and any value. You can use the attr function to get or set an attribute by name: attr(mtcars, &quot;row.names&quot;) ## [1] &quot;Mazda RX4&quot; &quot;Mazda RX4 Wag&quot; &quot;Datsun 710&quot; ## [4] &quot;Hornet 4 Drive&quot; &quot;Hornet Sportabout&quot; &quot;Valiant&quot; ## [7] &quot;Duster 360&quot; &quot;Merc 240D&quot; &quot;Merc 230&quot; ## [10] &quot;Merc 280&quot; &quot;Merc 280C&quot; &quot;Merc 450SE&quot; ## [13] &quot;Merc 450SL&quot; &quot;Merc 450SLC&quot; &quot;Cadillac Fleetwood&quot; ## [16] &quot;Lincoln Continental&quot; &quot;Chrysler Imperial&quot; &quot;Fiat 128&quot; ## [19] &quot;Honda Civic&quot; &quot;Toyota Corolla&quot; &quot;Toyota Corona&quot; ## [22] &quot;Dodge Challenger&quot; &quot;AMC Javelin&quot; &quot;Camaro Z28&quot; ## [25] &quot;Pontiac Firebird&quot; &quot;Fiat X1-9&quot; &quot;Porsche 914-2&quot; ## [28] &quot;Lotus Europa&quot; &quot;Ford Pantera L&quot; &quot;Ferrari Dino&quot; ## [31] &quot;Maserati Bora&quot; &quot;Volvo 142E&quot; attr(mtcars, &quot;foo&quot;) = 42 attr(mtcars, &quot;foo&quot;) ## [1] 42 You can get all of the attributes attached to an object with the attributes function: attributes(mtcars) ## $names ## [1] &quot;mpg&quot; &quot;cyl&quot; &quot;disp&quot; &quot;hp&quot; &quot;drat&quot; &quot;wt&quot; &quot;qsec&quot; &quot;vs&quot; &quot;am&quot; &quot;gear&quot; ## [11] &quot;carb&quot; ## ## $row.names ## [1] &quot;Mazda RX4&quot; &quot;Mazda RX4 Wag&quot; &quot;Datsun 710&quot; ## [4] &quot;Hornet 4 Drive&quot; &quot;Hornet Sportabout&quot; &quot;Valiant&quot; ## [7] &quot;Duster 360&quot; &quot;Merc 240D&quot; &quot;Merc 230&quot; ## [10] &quot;Merc 280&quot; &quot;Merc 280C&quot; &quot;Merc 450SE&quot; ## [13] &quot;Merc 450SL&quot; &quot;Merc 450SLC&quot; &quot;Cadillac Fleetwood&quot; ## [16] &quot;Lincoln Continental&quot; &quot;Chrysler Imperial&quot; &quot;Fiat 128&quot; ## [19] &quot;Honda Civic&quot; &quot;Toyota Corolla&quot; &quot;Toyota Corona&quot; ## [22] &quot;Dodge Challenger&quot; &quot;AMC Javelin&quot; &quot;Camaro Z28&quot; ## [25] &quot;Pontiac Firebird&quot; &quot;Fiat X1-9&quot; &quot;Porsche 914-2&quot; ## [28] &quot;Lotus Europa&quot; &quot;Ford Pantera L&quot; &quot;Ferrari Dino&quot; ## [31] &quot;Maserati Bora&quot; &quot;Volvo 142E&quot; ## ## $class ## [1] &quot;data.frame&quot; ## ## $foo ## [1] 42 You can use the structure function to set multiple attributes on an object: mod_mtcars = structure(mtcars, foo = 50, bar = 100) attributes(mod_mtcars) ## $names ## [1] &quot;mpg&quot; &quot;cyl&quot; &quot;disp&quot; &quot;hp&quot; &quot;drat&quot; &quot;wt&quot; &quot;qsec&quot; &quot;vs&quot; &quot;am&quot; &quot;gear&quot; ## [11] &quot;carb&quot; ## ## $row.names ## [1] &quot;Mazda RX4&quot; &quot;Mazda RX4 Wag&quot; &quot;Datsun 710&quot; ## [4] &quot;Hornet 4 Drive&quot; &quot;Hornet Sportabout&quot; &quot;Valiant&quot; ## [7] &quot;Duster 360&quot; &quot;Merc 240D&quot; &quot;Merc 230&quot; ## [10] &quot;Merc 280&quot; &quot;Merc 280C&quot; &quot;Merc 450SE&quot; ## [13] &quot;Merc 450SL&quot; &quot;Merc 450SLC&quot; &quot;Cadillac Fleetwood&quot; ## [16] &quot;Lincoln Continental&quot; &quot;Chrysler Imperial&quot; &quot;Fiat 128&quot; ## [19] &quot;Honda Civic&quot; &quot;Toyota Corolla&quot; &quot;Toyota Corona&quot; ## [22] &quot;Dodge Challenger&quot; &quot;AMC Javelin&quot; &quot;Camaro Z28&quot; ## [25] &quot;Pontiac Firebird&quot; &quot;Fiat X1-9&quot; &quot;Porsche 914-2&quot; ## [28] &quot;Lotus Europa&quot; &quot;Ford Pantera L&quot; &quot;Ferrari Dino&quot; ## [31] &quot;Maserati Bora&quot; &quot;Volvo 142E&quot; ## ## $class ## [1] &quot;data.frame&quot; ## ## $foo ## [1] 50 ## ## $bar ## [1] 100 Vectors usually don’t have attributes: attributes(5) ## NULL But the class function still returns a class: class(5) ## [1] &quot;numeric&quot; When a helper function exists to get or set an attribute, use the helper function rather than attr. This will make your code clearer and ensure that attributes with special behavior and requirements, such as dim, are set correctly. 1.4 S3 R provides several systems for object-oriented programming (OOP), a programming paradigm where code is organized into a collection of “objects” that interact with each other. These systems provide a way to create new data structures with customized behavior, and also underpin how some of R’s built-in functions work. The S3 system is particularly important for understanding R, because it’s the oldest and most widely-used. This section focuses on S3, while Section 1.5 provides an overview of R’s other OOP systems. The central idea of S3 is that some functions can be generic, meaning they perform different computations (and run different code) for different classes of objects. Conversely, every object has at least one class, which dictates how the object behaves. For most objects, the class is independent of type and is stored in the class attribute. You can get the class of an object with the class function. For example, the class of a data frame is data.frame: class(mtcars) ## [1] &quot;data.frame&quot; Some objects have more than one class. One example of this is matrices: m = matrix() class(m) ## [1] &quot;matrix&quot; &quot;array&quot; When an object has multiple classes, they’re stored in the class attribute in order from highest to lowest priority. So the matrix m will primarily behave like a matrix, but it can also behave like an array. The priority of classes is often described in terms of a child-parent relationship: array is the parent class of matrix, or equivalently, the class matrix inherits from the class array. 1.4.1 Method Dispatch A function is generic if it selects and calls another function, called a method, based on the class of one of its arguments. A generic function can have any number of methods, and each must have the same signature, or collection of parameters, as the generic. Think of a generic function’s methods as the range of different computations it can perform, or alternatively as the range of different classes it can accept as input. Method dispatch, or just dispatch, is the process of selecting a method based on the class of an argument. You can identify S3 generics because they always call the UseMethod function, which initiates S3 method dispatch. Many of R’s built-in functions are generic. One example is the split function, which splits a data frame or vector into groups: split ## function (x, f, drop = FALSE, ...) ## UseMethod(&quot;split&quot;) ## &lt;bytecode: 0x5636f27f2938&gt; ## &lt;environment: namespace:base&gt; Another is the plot function, which creates a plot: plot ## function (x, y, ...) ## UseMethod(&quot;plot&quot;) ## &lt;bytecode: 0x5636f6e1c528&gt; ## &lt;environment: namespace:base&gt; The UseMethod function requires the name of the generic (as a string) as its first argument. The second argument is optional and specifies the object to use for method dispatch. By default, the first argument to the generic is used for method dispatch. So for split, the argument for x is used for method dispatch. R checks the class of the argument and selects a matching method. You can use the methods function to list all of the methods of a generic. The methods for split are: methods(split) ## [1] split.data.frame split.Date split.default split.POSIXct ## see &#39;?methods&#39; for accessing help and source code Method names always have the form GENERIC.CLASS, where GENERIC is the name of the generic and CLASS is the name of a class. For instance, split.data.frame is the split method for objects with class data.frame. Methods named GENERIC.default are a special case: they are default methods, selected only if none of the other methods match the class during dispatch. So split.default is the default method for split. Most generic functions have a default method. Methods are ordinary R functions. For instance, the code for split.data.frame is: split.data.frame ## function (x, f, drop = FALSE, ...) ## { ## if (inherits(f, &quot;formula&quot;)) ## f &lt;- eval(attr(stats::terms(f), &quot;variables&quot;), x, environment(f)) ## lapply(split(x = seq_len(nrow(x)), f = f, drop = drop, ...), ## function(ind) x[ind, , drop = FALSE]) ## } ## &lt;bytecode: 0x5636f4842da8&gt; ## &lt;environment: namespace:base&gt; Sometimes methods are defined in privately packages and can’t be accessed by typing their name at the prompt. You can use the getAnywhere function to get the code for these methods. For instance, to get the code for plot.data.frame: getAnywhere(plot.data.frame) ## A single object matching &#39;plot.data.frame&#39; was found ## It was found in the following places ## registered S3 method for plot from namespace graphics ## namespace:graphics ## with value ## ## function (x, ...) ## { ## plot2 &lt;- function(x, xlab = names(x)[1L], ylab = names(x)[2L], ## ...) plot(x[[1L]], x[[2L]], xlab = xlab, ylab = ylab, ## ...) ## if (!is.data.frame(x)) ## stop(&quot;&#39;plot.data.frame&#39; applied to non data frame&quot;) ## if (ncol(x) == 1) { ## x1 &lt;- x[[1L]] ## if (class(x1)[1L] %in% c(&quot;integer&quot;, &quot;numeric&quot;)) ## stripchart(x1, ...) ## else plot(x1, ...) ## } ## else if (ncol(x) == 2) { ## plot2(x, ...) ## } ## else { ## pairs(data.matrix(x), ...) ## } ## } ## &lt;bytecode: 0x5636f427b680&gt; ## &lt;environment: namespace:graphics&gt; As a demonstration of method dispatch, consider this code to split the mtcars dataset by number of cylinders: split(mtcars, mtcars$cyl) The split function is generic and dispatches on its first argument. In this case, the first argument is mtcars, which has class data.frame. Since the method split.data.frame exists, R calls split.data.frame with the same arguments you used to call the generic split function. In other words, R calls: split.data.frame(mtcars, mtcars$cyl) When an object has more than one class, method dispatch considers them from left to right. For instance, matrices created with the matrix function have class matrix and also class array. If you pass a matrix to a generic function, R will first look for a matrix method. If there isn’t one, R will look for an array method. If there still isn’t one, R will look for a default method. If there’s no default method either, then R raises an error. The sloop package provides useful functions inspecting S3 classes, generics, and methods, as well as the method dispatch process. For example, you can use the s3_dispatch function to see which method will be selected when you call a generic: # install.packages(&quot;sloop&quot;) library(&quot;sloop&quot;) s3_dispatch(split(mtcars, mtcars$cyl)) ## =&gt; split.data.frame ## * split.default The selected method is indicated with an arrow =&gt;, while methods that were not selected are indicated with a star *. See ?s3_dispatch for complete details about the output from the function. 1.4.2 Creating Objects S3 classes are defined implicitly by their associated methods. To create a new class, decide what its structure will be and define some methods. To create an object of the class, set an object’s class attribute to the class name. For example, let’s create a generic function get_age that returns the age of an animal in terms of a typical human lifespan. First define the generic: get_age = function(animal) { UseMethod(&quot;get_age&quot;) } Next, let’s create a class Human to represent a human. Since humans are animals, let’s make each Human also have class Animal. You can use any type of object as the foundation for a class, but lists are often a good choice because they can store multiple named elements. Here’s how to create a Human object with a field age_years to store the age in years: lyra = list(age_years = 13) class(lyra) = c(&quot;Human&quot;, &quot;Animal&quot;) Class names can include any characters that are valid in R variable names. One common convention is to make them start with an uppercase letter, to distinguish them from variables. If you want to make constructing an object of a given class less ad-hoc (and error-prone), define a constructor function that returns a new object of a given class. A common convention is to give the constructor function the same name as the class: Human = function(age_years) { obj = list(age_years = age_years) class(obj) = c(&quot;Human&quot;, &quot;Animal&quot;) obj } asriel = Human(45) The get_age generic doesn’t have any methods yet, so R raises an error if you call it (regardless of the argument’s class): get_age(lyra) ## Error in UseMethod(&quot;get_age&quot;): no applicable method for &#39;get_age&#39; applied to an object of class &quot;c(&#39;Human&#39;, &#39;Animal&#39;)&quot; Let’s define a method for Animal objects. The method will just return the value of the age_years field: get_age.Animal = function(animal) { animal$age_years } get_age(lyra) ## [1] 13 get_age(asriel) ## [1] 45 Notice that the get_age generic still raises an error for objects that don’t have class Animal: get_age(3) ## Error in UseMethod(&quot;get_age&quot;): no applicable method for &#39;get_age&#39; applied to an object of class &quot;c(&#39;double&#39;, &#39;numeric&#39;)&quot; Now let’s create a class Dog to represent dogs. Like the Human class, a Dog is a kind of Animal and has an age_years field. Each Dog will also have a breed field to store the breed of the dog: Dog = function(age_years, breed) { obj = list(age_years = age_years, breed = breed) class(obj) = c(&quot;Dog&quot;, &quot;Animal&quot;) obj } pongo = Dog(10, &quot;dalmatian&quot;) Since a Dog is an Animal, the get_age generic returns a result: get_age(pongo) ## [1] 10 Recall that the goal of this example was to make get_age return the age of an animal in terms of a human lifespan. For a dog, their age in “human years” is about 5 times their age in actual years. You can implement a get_age method for Dog to take this into account: get_age.Dog = function(animal) { animal$age_years * 5 } Now the get_age generic returns an age in terms of a human lifespan whether its argument is a Human or a Dog: get_age(lyra) ## [1] 13 get_age(pongo) ## [1] 50 You can create new data structures in R by creating classes, and you can add functionality to new or existing generics by creating new methods. Before creating a class, think about whether R already provides a data structure that suits your needs. It’s uncommon to create new classes in the course of a typical data analysis, but many packages do provide new classes. Regardless of whether you ever create a new class, understanding the details means understanding how S3 works, and thus how R’s many S3 generic functions work. As a final note, while exploring S3 methods you may also encounter the NextMethod function. The NextMethod function redirects dispatch to the method that is the next closest match for an object’s class. You can learn more by reading ?NextMethod. 1.5 Other Object Systems R provides many systems for object-oriented programming besides S3. Some are built into the language, while others are provided by packages. A few of the most popular systems are: S4 – S4 is built into R and is the most widely-used system after S3. Like S3, S4 frames OOP in terms of generic functions and methods. The major differences are that S4 is stricter—the structure of each class must be formally defined—and that S4 generics can dispatch on the classes of multiple arguments instead of just one. R provides a special field operator @ to access fields of an S4 object. Most of the packages in the Bioconductor project use S4. Reference classes – Objects created with the S3 and S4 systems generally follow the copy-on-write rule, but this can be inefficient for some programming tasks. The reference class system is built into R and provides a way to create reference objects with a formal class structure (in the spirit of S4). This system is more like OOP systems in languages like Java and Python than S3 or S4 are. The reference class system is sometimes jokingly called “R5”, but that isn’t an official name. R6 – An alternative to reference classes created by Winston Chang, a developer at Posit (formerly RStudio). Claims to be simpler and faster than reference classes. R7 – A new OOP system being developed collaboratively by representatives from several different important groups in the R community, including the R core developers, Bioconductor, and Posit. Many of these systems are described in more detail in Hadley Wickham’s book Advanced R. "],["output-errors-and-bugs.html", "2 Output, Errors, and Bugs 2.1 Printing Output 2.2 The Conditions System 2.3 Global Options 2.4 Debugging 2.5 Measuring Performance", " 2 Output, Errors, and Bugs This chapter is part 2 (of 2) of Thinking in R, a workshop series about how R works and how to examine code critically. The major topics of this chapter are how to print output, how R’s conditions system for warnings and errors works, how to use the R debugger, and how to estimate the performance of R code. Learning Objectives Identify and explain the difference between R’s various printing functions Use R’s conditions system to raise and catch messages, warnings, and errors Use R’s debugging functions to diagnose bugs in code Estimate the amount of memory a data set will require Use the lobstr package to get memory usage for an R object Describe what a profiler is and why you would use one Describe what kinds of profiling tools R provides 2.1 Printing Output Perhaps the simplest thing you can do to get a better understanding of some code is make it print out lots of information about what’s happening as it runs. This section introduces several different functions for printing output and making that output easier to read. 2.1.1 The print Function The print function prints a string representation of an object to the console. The string representation is usually formatted in a way that exposes detail important programmers rather than users. For example, when printing a vector, the function prints the position of the first element on each line in square brackets [ ]: print(1:100) ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ## [19] 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 ## [37] 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 ## [55] 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 ## [73] 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 ## [91] 91 92 93 94 95 96 97 98 99 100 The print function also prints quotes around strings: print(&quot;Hi&quot;) ## [1] &quot;Hi&quot; These features make the print function ideal for printing information when you’re trying to understand some code or diagnose a bug. On the other hand, these features also make print a bad choice for printing output or status messages for users (including you). R calls the print function automatically anytime a result is returned at the prompt. Thus it’s not necessary to call print to print something when you’re working directly in the console—only from within loops, functions, scripts, and other code that runs non-interactively. The print function is an S3 generic (see Section 1.4), so you if you create an S3 class, you can define a custom print method for it. For S4 objects, R uses the S4 generic show instead of print. 2.1.2 The message Function To print output for users, the message function is the one you should use. The main reason for this is that the message function is part of R’s conditions system for reporting status information as code runs. This makes it easier for other code to detect, record, respond to, or suppress the output. Section 2.2 will explain the conditions system in more detail. The message function prints its argument(s) and a newline to the console: message(&quot;Hello world!&quot;) ## Hello world! If an argument isn’t a string, the function automatically and silently attempts to coerce it to one: message(4) ## 4 Some types of objects can’t be coerced to a string: message(sqrt) ## Error in FUN(X[[i]], ...): cannot coerce type &#39;builtin&#39; to vector of type &#39;character&#39; For objects with multiple elements, the function pastes together the string representations of the elements with no separators in between: x = c(1, 2, 3) message(x) ## 123 Similarly, if you pass the message function multiple arguments, it pastes them together with no separators: name = &quot;R&quot; message(&quot;Hi, my name is &quot;, name, &quot; and x is &quot;, x) ## Hi, my name is R and x is 123 This is a convenient way to print names or descriptions alongside values from your code without having to call a formatting function like paste. You can make the message function print something without adding a newline at the end by setting the argument appendLF = FALSE. The difference can be easy to miss unless you make several calls to message, so the say_hello function in this example calls message twice: say_hello = function(appendLF) { message(&quot;Hello&quot;, appendLF = appendLF) message(&quot; world!&quot;) } say_hello(appendLF = TRUE) ## Hello ## world! say_hello(appendLF = FALSE) ## Hello world! Note that RStudio always adds a newline in front of the prompt, so making an isolated call to message with appendLF = FALSE appears to produce the same output as with appendLF = TRUE. This is an example of a situation where RStudio leads you astray: in an ordinary R console, the two are clearly different. 2.1.3 The cat Function The cat function, whose name stands for “concatenate and print,” is a low-level way to print output to the console or a file. The message function prints output by calling cat, but cat is not part of R’s conditions system. The cat function prints its argument(s) to the console. It does not add a newline at the end: cat(&quot;Hello&quot;) ## Hello As with message, RStudio hides the fact that there’s no newline if you make an isolated call to cat. The cat function coerces its arguments to strings and concatenates them. By default, a space is inserted between arguments and their elements: cat(4) ## 4 cat(x) ## 1 2 3 cat(&quot;Hello&quot;, &quot;Nick&quot;) ## Hello Nick You can set the sep parameter to control the separator cat inserts: cat(&quot;Hello&quot;, &quot;world&quot;, x, sep = &quot;|&quot;) ## Hello|world|1|2|3 If you want to write output to a file rather than to the console, you can call cat with the file parameter set. However, it’s preferable to use functions tailored to writing specific kinds of data, such as writeLines (for text) or write.table (for tabular data), since they provide additional options to control the output. Many scripts and packages still use cat to print output, but the message function provides more flexibility and control to people running the code. Thus it’s generally preferable to use message in new code. Nevertheless, there are a few specific cases where cat is useful—for example, if you want to pipe data to a UNIX shell command. See ?cat for details. 2.1.4 Formatting Output R provides a variety of ways to format data before you print it. Taking the time to format output carefully makes it easier to read and understand, as well as making your scripts seem more professional. 2.1.4.1 Escape Sequences One way to format strings is by adding (or removing) escape sequences. An escape sequence is a sequence of characters that represents some other character, usually one that’s invisible (such as whitespace) or doesn’t appear on a standard keyboard. In R, escape sequences always begin with a backslash. For example, \\n is a newline. The message and cat functions automatically convert escape sequences to the characters they represent: x = &quot;Hello\\nworld!&quot; message(x) ## Hello ## world! The print function doesn’t convert escape sequences: print(x) ## [1] &quot;Hello\\nworld!&quot; Some escape sequences trigger special behavior in the console. For example, ending a line with a carriage return \\r makes the console print the next line over the line. Try running this code in a console (it’s not possible to see the result in a static book): # Run this in an R console. for (i in 1:10) { message(i, &quot;\\r&quot;, appendLF = FALSE) # Wait 0.5 seconds. Sys.sleep(0.5) } You can find a complete list of escape sequences in ?Quotes. 2.1.4.2 Formatting Functions You can use the sprintf function to apply specific formatting to values and substitute them into strings. The function uses a mini-language to describe the formatting and substitutions. The sprintf function (or something like it) is available in many programming languages, so being familiar with it will serve you well on your programming journey. The key idea is that substitutions are marked by a percent sign % and a character. The character indicates the kind of data to be substituted: s for strings, i for integers, f for floating point numbers, and so on. The first argument to sprintf must be a string, and subsequent arguments are values to substitute into the string (from left to right). For example: sprintf(&quot;My age is %i, and my name is %s&quot;, 32, &quot;Nick&quot;) ## [1] &quot;My age is 32, and my name is Nick&quot; You can use the mini-language to do things like specify how many digits to print after a decimal point. Format settings for a substituted value go between the percent sign % and the character. For instance, here’s how to print pi with 2 digits after the decimal: sprintf(&quot;%.2f&quot;, pi) ## [1] &quot;3.14&quot; You can learn more by reading ?sprintf. Much simpler are the paste and paste0 functions, which coerce their arguments to strings and concatenate (or “paste together”) them. The paste function inserts a space between each argument, while the paste0 function doesn’t: paste(&quot;Hello&quot;, &quot;world&quot;) ## [1] &quot;Hello world&quot; paste0(&quot;Hello&quot;, &quot;world&quot;) ## [1] &quot;Helloworld&quot; You can control the character inserted between arguments with the sep parameter. By setting an argument for the collapse parameter, you can also use the paste and paste0 functions to concatenate the elements of a vector. The argument to collapse is inserted between the elements. For example, suppose you want to paste together elements of a vector inserting a comma and space , in between: paste(1:3, collapse = &quot;, &quot;) ## [1] &quot;1, 2, 3&quot; Members of the R community have developed many packages to make formatting strings easier: cli – helper functions for developing command-line interfaces, including functions to add color, progress bars, and more. glue – alternatives to sprintf for string iterpolation. stringr – a collection of general-purpose string manipulation functions. 2.1.5 Logging Output Logging means saving the output from some code to a file as the code runs. The file where the output is saved is called a log file or log, but this name isn’t indicative of a specific format (unlike, say, a “CSV file”). It’s a good idea to set up some kind of logging for any code that takes more than a few minutes to run, because then if something goes wrong you can inspect the log to diagnose the problem. Think of any output that’s not logged as ephemeral: it could disappear if someone reboots the computer, or there’s a power outage, or some other, unforeseen event. R’s built-in tools for logging are rudimentary, but members of the community have developed a variety of packages for logging. Here are a few that are still actively maintained as of January 2023: logger – a relatively new package that aims to improve aspects of other logging packages that R users find confusing. futile.logger – a popular, mature logging package based on Apache’s Log4j utility and on R idioms. logging – a mature logging package based on Python’s logging module. loggit – integrates with R’s conditions system and writes logs in JavaScript Object Notation (JSON) format so they are easy to inspect programmatically. log4r – another package based on Log4j with an object-oriented programming approach. 2.2 The Conditions System R’s conditions system provides a way to signal and handle unusual conditions that arise while code runs. With the conditions system, you can make R print status, warning, and error messages that make it easier for users to understand what your code is doing and whether they’re using it as intended. The condition system also makes it possible to safely run code that might cause an error, and respond appropriately in the event that it does. In short, understanding the conditions system will enable you write code that’s easier to use and more robust. 2.2.1 Raising Conditions The message, warning, and stop functions are the primary ways to raise, or signal, conditions. The message function was described in Section 2.1.2. A message provides status information about running code, but does not necessarily indicate that something has gone wrong. You can use messages to print out any information you think might be relevant to users. The warning function raises a warning. Warnings indicate that something unexpected happened, but that it didn’t stop the code from running. By default, R doesn’t print warnings to the console until code finishes running, which can make it difficult to understand their cause; Section 2.3 explains how to change this setting. Unnamed arguments to the warning function are concatenated with no separator between them, in the same way as arguments to the message function. For example: warning(&quot;Objects in mirror&quot;, &quot; may be closer than they appear.&quot;) ## Warning: Objects in mirror may be closer than they appear. Warnings are always printed with Warning: before the message. By default, calling warning from the body of a function also prints the name of the function: f = function(x, y) { warning(&quot;This is a warning!&quot;) x + y } f(3, 4) ## Warning in f(3, 4): This is a warning! ## [1] 7 The name of the function that raised the warning is generally useful information for users that want to correct whatever caused the warning. Occasionally, you might want to disable this behavior, which you can do by setting call. = FALSE: f = function(x, y) { warning(&quot;This is a warning!&quot;, call. = FALSE) x + y } f(3, 4) ## Warning: This is a warning! ## [1] 7 The warning function also has several other parameters that control when and how warnings are displayed. The stop function raises an error, which indicates that something unexpected happened that prevents the code from running, and immediately stops the evaluation of code. As a result, R prints errors as soon as they’re raised. For instance, in this function, the line x + y never runs: f = function(x, y) { stop() x + y } f(3, 4) ## Error in f(3, 4): Like message and warning, the stop function concatenates its unnamed arguments into a message to print: stop(&quot;I&#39;m afraid something has gone terribly wrong.&quot;) ## Error in eval(expr, envir, enclos): I&#39;m afraid something has gone terribly wrong. Errors are always printed with Error: before the error message. You can use the call. parameter to control whether the error message also includes the name of the function from which stop was called. When writing code—especially functions, executable scripts, and packages—it’s a good habit to include tests for unexpected conditions such as invalid arguments and impossible results. If the tests detect a problem, use the warning or stop function (depending on severity) to signal what the problem is. Try to provide a concise but descriptive warning or error message so that users can easily understand what went wrong. 2.2.2 Handling Conditions In some cases, you can anticipate the problems likely to occur when code runs and can even devise ways to work around them. As an example, suppose your code is supposed to load parameters from a configuration file, but the path to the file provided by the user is invalid. It might still be possible for your code to run by falling back on a set of default parameters. R’s conditions system provides a way to handle or “catch” messages, warnings, and errors, and to run alternative code in response. You can use the try function to safely run code that might produce an error. If no error occurs, the try function returns whatever the result of the code was. If an error does occur, the try function prints the error message and returns an object of class try-error, but evaluation does not stop. For example: bad_add = function(x) { # No error x1 = try(5 + x) # Error x2 = try(&quot;yay&quot; + x) list(x1, x2) } bad_add(10) ## Error in &quot;yay&quot; + x : non-numeric argument to binary operator ## [[1]] ## [1] 15 ## ## [[2]] ## [1] &quot;Error in \\&quot;yay\\&quot; + x : non-numeric argument to binary operator\\n&quot; ## attr(,&quot;class&quot;) ## [1] &quot;try-error&quot; ## attr(,&quot;condition&quot;) ## &lt;simpleError in &quot;yay&quot; + x: non-numeric argument to binary operator&gt; The simplest thing you can do in response to an error is ignore it. This is usually not a good idea, but if you understand exactly what went wrong, can’t fix it easily, and know it won’t affect the rest of your code, doing so might be the best option. A more robust approach is to inspect the result from a call to try to see if an error occurred, and then take some appropriate action if one did. You can use the inherits function to check whether an object has a specific class, so here’s a template for how to run code that might cause an error, check for the error, and respond to it: result = try({ # Code that might cause an error. }) if (inherits(result, &quot;try-error&quot;)) { # Code to respond to the error. } You can prevent the try function from printing error messages by setting silent = TRUE. This is useful when your code is designed to detect and handle the error, so you don’t users to think an error occurred. The tryCatch function provides another way to handle conditions raised by a piece of code. It requires that you provide a handler function for each kind of condition you want to handle. The kinds of conditions are: message warning error interrupt – when the user interrupts the code (for example, by pressing Ctrl-C) Each handler function must accept exactly one argument. When you call tryCatch, if the suspect code raises a condition, then it calls the associated handler function and returns whatever the handler returns. Otherwise, tryCatch returns the result of the code. Here’s an example of using tryCatch to catch an error: bad_fn = function(x, y) { stop(&quot;Hi&quot;) x + y } err = tryCatch(bad_fn(3, 4), error = function(e) e) And here’s an example of using tryCatch to catch a message: msg_fn = function(x, y) { message(&quot;Hi&quot;) x + y } msg = tryCatch(msg_fn(3, 4), message = function(e) e) The tryCatch function always silences conditions. Details about raised conditions are provided in the object passed to the handler function, which has class condition (and a more specific class that indicates what kind of condition it is). If you want to learn more about R’s conditions system, start by reading ?conditions. 2.3 Global Options R’s global options to control many different aspects of how R works. They’re relevant to the theme of this chapter because some of them control when and how R displays warnings and errors. You can use the options function to get or set global options. If you call the function with no arguments, it returns the current settings: opts = options() # Display the first 6 options. head(opts) ## $add.smooth ## [1] TRUE ## ## $bitmapType ## [1] &quot;cairo&quot; ## ## $browser ## [1] &quot;&quot; ## ## $browserNLdisabled ## [1] FALSE ## ## $callr.condition_handler_cli_message ## function (msg) ## { ## custom_handler &lt;- getOption(&quot;cli.default_handler&quot;) ## if (is.function(custom_handler)) { ## custom_handler(msg) ## } ## else { ## cli_server_default(msg) ## } ## } ## &lt;bytecode: 0x55bad483e920&gt; ## &lt;environment: namespace:cli&gt; ## ## $CBoundsCheck ## [1] FALSE This section only explains a few of the options, but you can read about all of them in ?options. The warn option controls how R handles warnings. It can be set to three different values: 0 – (the default) warnings are only displayed after code finishes running. 1 – warnings are displayed immediately. 2 – warnings stop code from running, like errors. Setting warn = 2 is useful for pinpointing expressions that raise warnings. Setting warn = 1 makes it easier to determine which expressions raise warnings, without the inconvenience of stopping code from running. That makes it a good default (better than the actual default). You can use the option function to change the value of the warn option: options(warn = 1) When you set an option this way, the change only lasts until you quit R. Next time you start R, the option will go back to its default value. Fortunately, there is a way override the default options every time R starts. When R starts, it searches for a .Rprofile file. The file is usually in your system’s home directory (see this section of the R Basics Reader for how to locate your home directory). Customizing your .Rprofile file is one of the marks of an experienced R user. If you define a .First function in your .Rprofile, R will call it automatically during startup. Here’s an example .First function: .First = function() { # Only change options if R is running interactively. if (!interactive()) return() options( # Don&#39;t print more than 1000 elements of anything. max.print = 1000, # Warn on partial matches. warnPartialMatchAttr = TRUE, warnPartialMatchDollar = TRUE, warnPartialMatchArgs = TRUE, # Print warnings immediately (2 = warnings are errors). warn = 1 ) } You can learn more about the .Rprofile file and R’s startup process at ?Startup. 2.4 Debugging Debugging code is the process of confirming, step-by-step, that what you believe the code does is what the code actually does. The key idea is to check each step (or expression) in the code. There are two different strategies for doing this: Work forward through the code from the beginning. Work backward from the source of an error. R has built-in functions to help with debugging. The browser() function pauses the running code and starts R’s debugging system. For example: # Run this in an R console. f = function(n) { total = 0 for (i in 1:n) { browser() total = total + i } total } f(10) The most important debugger commands are: n to run the next line s to “step into” a call c to continue running the code Q to quit the debugger where to print call stack help to print debugger help Another example: # Run this in an R console. g = function(x, y) (1 + x) * y f = function(n) { total = 0 for (i in 1:n) { browser() total = total + g(i, i) } total } f(11) 2.4.1 Other Functions The debug() function places a call to browser() at the beginning of a function. Use debug() to debug functions that you can’t or don’t want to edit. For example: # Run this in an R console. f = function(x, y) { x + y } debug(f) f(5, 5) You can use undebug() to reverse the effect of debug(): # Run this in an R console. undebug(f) f(10, 20) The debugonce() function places a call to browser() at the beginning of a function for the next call only. The idea is that you then don’t have to call undebug(). For instance: # Run this in an R console. debugonce(f) f(10, 20) f(3, 4) Finally, the global option error can be used to make R enter the debugger any time an error occurs. Set the option to error = recover: options(error = recover) Then try this example: # Run this in an R console. bad_fn = function(x, y) { stop(&quot;Hi&quot;) x + y } bad_fn(3, 4) 2.5 Measuring Performance How quickly code runs and how much memory it uses can be just as much of an obstacle to research computing tasks as errors and bugs. This section describes some of the strategies you can use to estimate or measure the performance characteristics of code, so that you can identify potential problems and fix them. 2.5.1 Estimating Memory Usage Running out of memory can be extremely frustrating, because it can slow down your code or prevent it from running at all. It’s useful to know how to estimate how much memory a given data structure will use so that you can determine whether a programming strategy is feasible before you even start writing code. The central processing units (CPUs) in most modern computers are designed to work most efficiently with 64 bits of data at a time. Consequently, R and other programming languages typically use 64 bits to store each number (regardless of type). While the data structures R uses create some additional overhead, you can use this fact to do back-of-the-envelope calculations about how much memory a vector or matrix of numbers will require. Start by determining how many elements the data structure will contain. Then multiply by 64 bits and divide by 8 to convert bits to bytes. You can then repeatedly divide by 1024 to convert to kilobytes, megabytes, gigabytes, or terabytes. For instance, an vector of 2 million numbers will require approximately this many megabytes: n = 2000000 n * (64 / 8) / 1024^2 ## [1] 15.25879 You can even write an R function to do these calculations for you! If you’re not sure whether a particular programming strategy is realistic, do the memory calculations before you start writing code. This is a simple way to avoid strategies that are inefficient. If you’ve already written some code and it runs out of memory, the first step to fixing the problem is identifying the cause. The lobstr package provides functions to explore how R is using memory. You can use the mem_used function to get the amount of memory R is currently using: library(&quot;lobstr&quot;) mem_used() ## 42.52 MB Sometimes the culprit isn’t your code, but other applications on your computer. Modern web browsers are especially memory-intensive, and closing yours while you run code can make a big difference. If you’ve determined that your code is the reason R runs out of memory, you can use the obj_size function to get how much memory objects in your code actually use: obj_size(1) ## 56 B x = runif(n) obj_size(x) ## 16.00 MB obj_size(mtcars) ## 7.21 kB If a specific object created by your code uses a lot of memory, think about ways you might change the code to avoid creating the object or avoid creating the entire object at once. For instance, consider whether it’s possible to create part of the object, save that to disk, remove it from memory, and then create the another part. 2.5.2 Benchmarking Benchmarking means timing how long code takes to run. Benchmarking is useful for evaluating different strategies to solve a computational problem and for understanding how quickly (or slowly) your code runs. When you benchmark code, it’s important to collect and aggregate multiple data points so that your estimates reflect how the code performs on average. R has built-in functions for timing code, but several packages provide functions that are more convenient for benchmarking, because they automatically run the code multiple times and return summary statistics. The two most mature packages for benchmarking are: microbenchmark bench The microbenchmark package is simpler to use. It provides a single function, microbenchmark, for carrying out benchmarks. The function accepts any number of expressions to benchmark as arguments. For example, to compare the speed of runif and rnorm (as A and B respectively): library(&quot;microbenchmark&quot;) microbenchmark(A = runif(1e5), B = rnorm(1e5)) ## Unit: milliseconds ## expr min lq mean median uq max neval cld ## A 2.862452 3.135050 3.221409 3.159137 3.236859 7.727636 100 a ## B 5.784193 6.116514 6.331203 6.172219 6.236584 11.490630 100 b The microbenchmark has parameters to control the number of times each expression runs, the units for the timings, and more. You can find the details in ?microbenchmark. 2.5.3 Profiling Profiling code means collecting data about the code as it runs, and a profiler is a program that profiles code. A typical profiler estimates how much time is spent on each expression (as actual time or as a percentage of total runtime) and how much memory the code uses over time. Profiling is a good way to determine which parts of your code are performance bottlenecks, so that you can target them when you try to optimize your code. R has a built-in profiler. You can use the Rprof function to enable or disable the profiler. Essential parameters for the function are: filename – a path to a file for storing results. Defaults to Rprof.out. interval – the time between samples, in seconds. memory.profiling – whether to track memory in addition to time. Set these parameters in the first call you make to Rprof, which will enable the profiler. Then run the code you want to profile. At the end of the code, call Rprof(NULL) to disable the profiler. The profiler saves the collected data to a file. You can use the summaryRprof function to read the profile data and get a summary. Essential parameters for this function are: filename – the path to the results file. Defaults to Rprof.out. memory – how to display memory information. Use \"both\" to see total changes. The summary lists times in seconds and memory in bytes. The profvis package provides an interactive graphical interface for exploring profile data collected with Rprof. Examining profile data graphically makes it easier to interpret the results and to identify patterns. "],["string-date-processing.html", "3 String &amp; Date Processing 3.1 The Tidyverse 3.2 Date Processing 3.3 Printing Output 3.4 Escape Sequences 3.5 Character Encodings 3.6 The stringr Package 3.7 Regular Expressions", " 3 String &amp; Date Processing 3.1 The Tidyverse The Tidyverse is a popular collection of packages for doing data science in R. The packages are made by many of the same people that make RStudio. They provide alternatives to R’s built-in tools for: Manipulating strings (package stringr) Making visualizations (package ggplot2) Reading files (package readr) Manipulating data frames (packages dplyr, tidyr, tibble) And more Think of the Tidyverse as a different dialect of R. Sometimes the syntax is different, and sometimes ideas are easier or harder to express concisely. Whether to use base R or the Tidyverse is mostly subjective. As a result, the Tidyverse is somewhat polarizing in the R community. It’s useful to be literate in both, since both are popular. One advantage of the Tidyverse is that the packages are usually well-documented. For example, there are documentation websites and cheat sheets for most Tidyverse packages. 3.2 Date Processing Besides strings, dates and times are another kind of data that require special attention to prepare for analysis. This is especially important if you want to do anything that involves sorting dates, like making a line plot with dates on one axis. Dates may not be sorted correctly if they haven’t been converted to one of R’s date classes. There several built-in functions and also many packages for date processing. As with visualization and string processing, the Tidyverse packages have the best combination of simple design and clear documentation. There are three Tidyverse packages for processing dates and times: lubridate, the primary package for working with dates and times hms, a package specifically for working with times clock, a new package for working with dates and times We’ll focus on the lubridate package. As always, you’ll have to install the package if you haven’t already, and then load it: # install.packages(&quot;lubridate&quot;) library(&quot;lubridate&quot;) ## ## Attaching package: &#39;lubridate&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## date, intersect, setdiff, union The most common task is to convert a string into a date or time class. For instance, when you load a data set, you might have dates that look like this: dates = c(&quot;Jan 10, 2021&quot;, &quot;Sep 3, 2018&quot;, &quot;Feb 28, 1982&quot;) dates ## [1] &quot;Jan 10, 2021&quot; &quot;Sep 3, 2018&quot; &quot;Feb 28, 1982&quot; These are strings, so it’s relatively difficult to sort the dates, do arithmetic on them, or extract just one part (such as the year). There are several lubridate functions to automatically convert strings into dates. They are named with one letter for each part of the date. For instance, the dates in the example have the month (m), then the day (d), and then the year (y), so we can use the mdy function: result = mdy(dates) result ## [1] &quot;2021-01-10&quot; &quot;2018-09-03&quot; &quot;1982-02-28&quot; class(result) ## [1] &quot;Date&quot; Notice that the dates now have class Date, one of R’s built-in classes for representing dates, and that they print differently. You can find a full list of the automatic string to date conversion functions in the lubridate documentation. Occasionally, a date string may have a format that lubridate can’t convert automatically. In that case, you can use the fast_strptime function to describe the format in detail. At a minimum, the function requires two arguments: the vector of strings to convert and a format string. The format string describes the format of the dates, and is based on the syntax of strptime, a function provided by many programming languages for converting strings to dates (including R). In a format string, a percent sign % followed by a character is called a specification and has a special meaning. Here are a few of the most useful ones: Specification Description January 29, 2015 %Y 4-digit year 2015 %y 2-digit year 15 %m 2-digit month 01 %B full month name January %b short month name Jan %d day of month 29 %% literal % % You can find a complete list in ?fast_strptime. Other characters in the format string do not have any special meaning. Write the format string so that it matches the format of the dates you want to convert. For example, let’s try converting an unusual time format: odd_time = &quot;6 minutes, 32 seconds after 10 o&#39;clock&quot; fast_strptime(odd_time, &quot;%M minutes, %S seconds after %H o&#39;clock&quot;) ## [1] &quot;0-01-01 10:06:32 UTC&quot; R usually represents dates with the class Date, and date-times with the classes POSIXct and POSIXlt. The difference between the two date-time classes is somewhat technical, but you can read more about it in ?POSIXlt. There is no built-in class to represent times alone, which is why the result in the example above includes a date. Nonetheless, the hms package provides the hms class to represent times without dates. Once you’ve converted a string to a date, the lubridate package provides a variety of functions to get or set the parts individually. Here are a few examples: day(result) ## [1] 10 3 28 month(result) ## [1] 1 9 2 You can find a complete list in the lubridate documentation. 3.2.1 Case Study: Correcting Dates 3.3 Printing Output The cat function prints a string in the R console. If you pass multiple arguments, they will be concatenated: cat(&quot;Hello&quot;) ## Hello cat(&quot;Hello&quot;, &quot;Nick&quot;) ## Hello Nick Pitfall 1: Printing a string is different from returning a string. The cat function only prints (and always returns NULL). For example: f = function() { cat(&quot;Hello&quot;) } x = f() ## Hello x ## NULL If you just want to concatenate some strings (but not necessarily print them), use paste instead of cat. The paste function returns a string. The str_c function in stringr (a package we’ll learn about later in this lesson) can also concatenate strings. Pitfall 2: Remember to print strings with the cat function, not the print function. The print function prints R’s representation of an object, the same as if you had entered the object in the console without calling print. For instance, print prints quotes around strings, whereas cat does not: print(&quot;Hello&quot;) ## [1] &quot;Hello&quot; cat(&quot;Hello&quot;) ## Hello 3.4 Escape Sequences In a string, an escape sequence or escape code consists of a backslash followed by one or more characters. Escape sequences make it possible to: Write quotes or backslashes within a string Write characters that don’t appear on your keyboard (for example, characters in a foreign language) For example, the escape sequence \\n corresponds to the newline character. Notice that the cat function translates \\n into a literal new line, whereas the print function doesn’t: x = &quot;Hello\\nNick&quot; cat(x) ## Hello ## Nick print(x) ## [1] &quot;Hello\\nNick&quot; As another example, suppose we want to put a literal quote in a string. We can either enclose the string in the other kind of quotes, or escape the quotes in the string: x = &#39;She said, &quot;Hi&quot;&#39; cat(x) ## She said, &quot;Hi&quot; y = &quot;She said, \\&quot;Hi\\&quot;&quot; cat(y) ## She said, &quot;Hi&quot; Since escape sequences begin with backslash, we also need to use an escape sequence to write a literal backslash. The escape sequence for a literal backslash is two backslashes: x = &quot;\\\\&quot; cat(x) ## \\ There’s a complete list of escape sequences for R in the ?Quotes help file. Other programming languages also use escape sequences, and many of them are the same as in R. 3.4.1 Raw Strings A raw string is a string where escape sequences are turned off. Raw strings are especially useful for writing regular expressions, which we’ll do later in this lesson. Raw strings begin with r\" and an opening delimiter (, [, or {. Raw strings end with a matching closing delimiter and quote. For example: x = r&quot;(quotes &quot; and backslashes \\)&quot; cat(x) ## quotes &quot; and backslashes \\ Raw strings were added to R in version 4.0 (April 2020), and won’t work correctly in older versions. 3.5 Character Encodings Computers store data as numbers. In order to store text on a computer, we have to agree on a character encoding, a system for mapping characters to numbers. For example, in ASCII, one of the most popular encodings in the United States, the character a maps to the number 97. Many different character encodings exist, and sharing text used to be an inconvenient process of asking or trying to guess the correct encoding. This was so inconvenient that in the 1980s, software engineers around the world united to create the Unicode standard. Unicode includes symbols for nearly all languages in use today, as well as emoji and many ancient languages (such as Egyptian hieroglyphs). Unicode maps characters to numbers, but unlike a character encoding, it doesn’t dictate how those numbers should be mapped to bytes (sequences of ones and zeroes). As a result, there are several different character encodings that support and are synonymous with Unicode. The most popular of these is UTF-8. In R, we can write Unicode characters with the escape sequence \\U followed by the number for the character in base 16. For instance, the number for a in Unicode is 97 (the same as in ASCII). In base 16, 97 is 61. So we can write an a as: x = &quot;\\U61&quot; # or &quot;\\u61&quot; x ## [1] &quot;a&quot; Unicode escape sequences are usually only used for characters that are not easy to type. For example, the cat emoji is number 1f408 (in base 16) in Unicode. So the string \"\\U1f408\" is the cat emoji. Note that being able to see printed Unicode characters also depends on whether the font your computer is using has a glyph (image representation) for that character. Many fonts are limited to a small number of languages. The NerdFont project patches fonts commonly used for programming so that they have better Unicode coverage. Using a font with good Unicode coverage is not essential, but it’s convenient if you expect to work with many different natural languages or love using emoji. 3.5.0.1 Character Encodings in Text Files Most of the time, R will handle character encodings for you automatically. However, if you ever read or write a text file (including CSV and other formats) and the text looks like gibberish, it might be an encoding problem. This is especially true on Windows, the only modern operating system that does not (yet) use UTF-8 as the default encoding. Encoding problems when reading a file can usually be fixed by passing the encoding to the function doing the reading. For instance, the code to read a UTF-8 encoded CSV file on Windows is: read.csv(&quot;my_data.csv&quot;, fileEncoding = &quot;UTF-8&quot;) Other reader functions may use a different parameter to set the encoding, so always check the documentation. On computers where the native language is not set to English, it can also help to set R’s native language to English with Sys.setlocale(locale = \"English\"). Encoding problems when writing a file are slightly more complicated to fix. See this blog post for thorough explanation. 3.6 The stringr Package The rest of this lesson uses stringr, the Tidyverse package for string processing. R also has built-in functions for string processing. The main advantage of stringr is that all of the functions use a common set of parameters, so they’re easier to learn and remember. In practice, data sets often require some cleaning before or during data analysis. One common data cleaning task is editing or extracting parts of strings. stringr has detailed documentation and also a cheatsheet. The first time you use stringr, you’ll have to install it with install.packages (the same as any other package). Then you can load the package with the library function: # install.packages(&quot;stringr&quot;) library(stringr) The typical syntax of a stringr function is: str_NAME(string, pattern, ...) Where: NAME describes what the function does string is the string to search within or transform pattern is the pattern to search for ... is additional, function-specific arguments For example, the str_detect function detects whether the pattern appears within the string: str_detect(&quot;hello&quot;, &quot;el&quot;) ## [1] TRUE str_detect(&quot;hello&quot;, &quot;ol&quot;) ## [1] FALSE Most of the stringr functions are vectorized in the string parameter: str_detect(c(&quot;hello&quot;, &quot;goodbye&quot;, &quot;lo&quot;), &quot;lo&quot;) ## [1] TRUE FALSE TRUE There are a lot of stringr functions. The remainder of this lesson focuses on three that are especially important, as well as some of their variants: str_split_fixed str_replace str_match You can find a complete list of stringr functions with examples in the documentation or cheat sheet. 3.6.1 Splitting Strings The str_split function splits the string at each position that matches the pattern. The characters that match are thrown away. For example, suppose we want to split a sentence into words. Since there’s a space between each word, we can use a space as the pattern: x = &quot;The students in this workshop are great!&quot; result = str_split(x, &quot; &quot;) result ## [[1]] ## [1] &quot;The&quot; &quot;students&quot; &quot;in&quot; &quot;this&quot; &quot;workshop&quot; &quot;are&quot; &quot;great!&quot; The str_split function always returns a list with one element for each input string. Here the list only has one element because x only has one element. We can get the first element with: result[[1]] ## [1] &quot;The&quot; &quot;students&quot; &quot;in&quot; &quot;this&quot; &quot;workshop&quot; &quot;are&quot; &quot;great!&quot; We have to use the double square bracket [[ operator here because x is a list (for a vector, we could use the single square bracket operator instead). Notice that in the printout for result, R gives us a hint that we should use [[ by printing [[1]]. To see why the function returns a list, consider what happens if we try to split two different sentences at once: x = c(x, &quot;Are you listening?&quot;) result = str_split(x, &quot; &quot;) result[[1]] ## [1] &quot;The&quot; &quot;students&quot; &quot;in&quot; &quot;this&quot; &quot;workshop&quot; &quot;are&quot; &quot;great!&quot; result[[2]] ## [1] &quot;Are&quot; &quot;you&quot; &quot;listening?&quot; Each sentence has a different number of words, so the vectors in the result have different lengths. So a list is the only way to store both. The str_split_fixed function is almost the same as str_split, but takes a third argument for the maximum number of splits to make. Because the number of splits is fixed, the function can return the result in a matrix instead of a list. For example: str_split_fixed(x, &quot; &quot;, 3) ## [,1] [,2] [,3] ## [1,] &quot;The&quot; &quot;students&quot; &quot;in this workshop are great!&quot; ## [2,] &quot;Are&quot; &quot;you&quot; &quot;listening?&quot; The str_split_fixed function is often more convenient than str_split because the nth piece of each input string is just the nth column of the result. For example, suppose we want to get the area code from some phone numbers: phones = c(&quot;717-555-3421&quot;, &quot;629-555-8902&quot;, &quot;903-555-6781&quot;) result = str_split_fixed(phones, &quot;-&quot;, 3) result[, 1] ## [1] &quot;717&quot; &quot;629&quot; &quot;903&quot; 3.6.2 Replacing Parts of Strings The str_replace function replaces the pattern the first time it appears in the string. The replacement goes in the third argument. For instance, suppose we want to change the word \"dog\" to \"cat\": x = c(&quot;dogs are great, dogs are fun&quot;, &quot;dogs are fluffy&quot;) str_replace(x, &quot;dog&quot;, &quot;cat&quot;) ## [1] &quot;cats are great, dogs are fun&quot; &quot;cats are fluffy&quot; The str_replace_all function replaces the pattern every time it appears in the string: str_replace_all(x, &quot;dog&quot;, &quot;cat&quot;) ## [1] &quot;cats are great, cats are fun&quot; &quot;cats are fluffy&quot; We can also use the str_replace and str_replace_all functions to delete part of a string by setting the replacement to the empty string \"\". For example, suppose we want to delete the comma: str_replace(x, &quot;,&quot;, &quot;&quot;) ## [1] &quot;dogs are great dogs are fun&quot; &quot;dogs are fluffy&quot; In general, stringr functions with the _all suffix affect all matches. Functions without _all only affect the first match. We’ll learn about str_match at the end of the next section. 3.7 Regular Expressions The stringr functions (including the ones we just learned) use a special language called regular expressions or regex for the pattern. The regular expressions language is also used in many other programming languages besides R. A regular expression can describe a complicated pattern in just a few characters, because some characters, called metacharacters, have special meanings. Letters and numbers are never metacharacters. They’re always literal. Here are a few examples of metacharacters (we’ll look at examples in the subsequent sections): Metacharacter Meaning . any single character (wildcard) \\ escape character (in both R and regex) ^ beginning of string $ end of string [ab] 'a' or 'b' [^ab] any character except 'a' or 'b' ? previous character appears 0 or 1 times * previous character appears 0 or more times + previous character appears 1 or more times () make a group More metacharacters are listed on the stringr cheatsheet, or in ?regex. The str_view function is especially helpful for testing regular expressions. It opens a browser window with the first match in the string highlighted. We’ll use it in the subsequent regex examples. The RegExr website is also helpful for testing regular expressions; it provides an interactive interface where you can write regular expressions and see where they match a string. 3.7.1 The Wildcard The regex wildcard character is . and matches any single character. For example: x = &quot;dog&quot; str_view(x, &quot;d.g&quot;) By default, regex searches from left to right: str_view(x, &quot;.&quot;) 3.7.2 Escape Sequences Like R, regular expressions can contain escape sequences that begin with a backslash. These are computed separately and after R escape sequences. The main use for escape sequences in regex is to turn a metacharacter into a literal character. For example, suppose we want to match a literal dot .. The regex for a literal dot is \\.. Since backslashes in R strings have to be escaped, the R string for this regex is \"\\\\.. Then the regex works: str_view(&quot;this.string&quot;, &quot;\\\\.&quot;) The double backslash can be confusing, and it gets worse if we want to match a literal backslash. We have to escape the backslash in the regex (because backslash is the regex escape character) and then also have to escape the backslashes in R (because backslash is also the R escape character). So to match a single literal backslash in R, the code is: str_view(&quot;this\\\\that&quot;, &quot;\\\\\\\\&quot;) Raw strings are helpful here, because they make the backslash literal in R strings (but still not in regex). We can use raw strings to write the above as: str_view(r&quot;(this\\that)&quot;, r&quot;(\\\\)&quot;) You can turn off regular expressions entirely in stringr with the fixed function: str_view(x, fixed(&quot;.&quot;)) It’s good to turn off regular expressions whenever you don’t need them, both to avoid mistakes and because they take longer to compute. 3.7.3 Anchors By default, a regex will match anywhere in the string. If you want to force a match at specific place, use an anchor. The beginning of string anchor is ^. It marks the beginning of the string, but doesn’t count as a character in the match. For example, suppose we want to match an a at the beginning of the string: x = c(&quot;abc&quot;, &quot;cab&quot;) str_view(x, &quot;a&quot;) str_view(x, &quot;^a&quot;) It doesn’t make sense to put characters before ^, since no characters can come before the beginning of the string. Likewise, the end of string anchor is $. It marks the end of the string, but doesn’t count as a character in the match. 3.7.4 Character Classes In regex, square brackets [ ] create a character class. A character class counts as one character, but that character can be any of the characters inside the square brackets. The square brackets themselves don’t count as characters in the match. For example, suppose we want to match a c followed by either a or t: x = c(&quot;ca&quot;, &quot;ct&quot;, &quot;cat&quot;, &quot;cta&quot;) str_view(x, &quot;c[ta]&quot;) You can use a dash - in a character class to create a range. For example, to match letters p through z: str_view(x, &quot;c[p-z]&quot;) Ranges also work with numbers and capital letters. To match a literal dash, place the dash at the end of the character class (instead of between two other characters), as in [abc-]. Most metacharacters are literal when inside a character class. For example, [.] matches a literal dot. A hat ^ at the beginning of the character class negates the class. So for example, [^abc] matches any one character except for a, b, or c: str_view(&quot;abcdef&quot;, &quot;[^abc]&quot;) 3.7.5 Quantifiers Quantifiers are metacharacters that affect how many times the preceeding character must appear in a match. The quantifier itself doesn’t count as a character in the match. For example, the ? quantifier means the preceeding character can appear 0 or 1 times. In other words, ? makes the preceeding character optional. For example: x = c(&quot;abc&quot;, &quot;ab&quot;, &quot;ac&quot;, &quot;abbc&quot;) str_view(x, &quot;ab?c&quot;) The * quantifier means the preceeding character can appear 0 or more times. In other words, * means the preceeding character can appear any number of times or not at all. str_view(x, &quot;ab*c&quot;) The + quantifier means the preceeding character must appear 1 or more times. Quantifiers are greedy, meaning they always match as many characters as possible. 3.7.6 Groups In regex, parentheses create a group. Groups can be affected by quantifiers, making it possible to repeat a pattern (rather than just a character). The parentheses themselves don’t count as characters in the match. For example: x = c(&quot;cats, dogs, and frogs&quot;, &quot;cats and frogs&quot;) str_view(x, &quot;cats(, dogs,)? and frogs&quot;) 3.7.7 Extracting Matches Groups are espcially useful with the stringr functions str_match and str_match_all. The str_match function extracts the overall match to the pattern, as well as the match to each group. So you can use str_match to split a string in more complicated ways than str_split, or to extract specifc pieces of a string. For example, suppose we want to split an email address: str_match(&quot;naulle@ucdavis.edu&quot;, &quot;([^@]+)@(.+)[.](.+)&quot;) ## [,1] [,2] [,3] [,4] ## [1,] &quot;naulle@ucdavis.edu&quot; &quot;naulle&quot; &quot;ucdavis&quot; &quot;edu&quot; 3.7.8 Case Study: Extracting Emails "],["automating-tasks.html", "4 Automating Tasks 4.1 Loops 4.2 Planning for Iteration", " 4 Automating Tasks 4.1 Loops One major benefit of using a programming language like R is that repetitive tasks can be automated. We’ve already seen two ways to do this: Vectorization, introduced in Section ?? Apply functions, introduced in Section ?? Both of these are iteration strategies. They iterate over some object, and compute something for each element. Each one of these computations is one iteration. Vectorization is the most efficient iteration strategy, but only works with vectorized functions and vectors. Apply functions are more flexible—they work with any function and any data structure with elements—but less efficient and less concise. A loop is another iteration strategy, one that’s even more flexible than apply functions. Besides being flexible, loops are a feature of almost all modern programming languages, so it’s useful to understand them. In R, there are two kinds of loops. We’ll learn both. 4.1.1 For-loops A for-loop runs a block of code once for each element of a vector or list. The for keyword creates a for-loop. Here’s the syntax: for (I in DATA) { # Your code goes here } The variable I is called the induction variable. At the beginning of each iteration, I is assigned the next element of the vector or list DATA. The loop iterates once for each element of DATA, unless you use a keyword to exit the loop early (more about this in Section 4.1.4). As with if-statements and functions, the curly braces { } are only required if the body contains multiple lines of code. Unlike the other iteration strategies, loops do not automatically return a result. You have complete control over the output, which means that anything you want to save must be assigned to a variable. For example, let’s make a loop that repeatedly adds a number to a running total and squares the new total. We’ll use a variable total to keep track of the running total as the loop iterates: numbers = c(-1, 1, -3, 2) total = 0 for (number in numbers) { total = (total + number)^2 } total ## [1] 9 Use for-loops when some or all of the iterations depend on results from other iterations. If the iterations are not dependent, use one of: Vectorization (because it’s faster) Apply functions (because they’re idiomatic) In some cases, you can use vectorization even when the iterations are dependent. For example, you can use vectorization to compute the sum of the cubes of several numbers: sum(numbers^3) ## [1] -19 4.1.2 While-loops A while-loop runs a block of code repeatedly as long as some condition is TRUE. The while keyword creates a while-loop. Here’s the syntax: while (CONDITION) { # Your code goes here } The CONDITION should be a scalar logical value or an expression that returns one. At the beginning of each iteration, CONDITION is checked, and the loop exits if it is FALSE. As always, the curly braces { } are only required if the body contains multiple lines of code. For example, suppose you want to add up numbers from 0 to 50, but stop as soon as the total is greater than 50: num50 = seq(0, 50) total = 0 i = 1 while (total &lt; 50) { total = total + num50[i] message(&quot;i is &quot;, i, &quot; total is &quot;, total) i = i + 1 } ## i is 1 total is 0 ## i is 2 total is 1 ## i is 3 total is 3 ## i is 4 total is 6 ## i is 5 total is 10 ## i is 6 total is 15 ## i is 7 total is 21 ## i is 8 total is 28 ## i is 9 total is 36 ## i is 10 total is 45 ## i is 11 total is 55 total ## [1] 55 i ## [1] 12 While-loops are a generalization of for-loops. They tend to be most useful when you don’t know how many iterations will be necessary. For example, suppose you want to repeat a computation until the result falls within some range of values. 4.1.3 Saving Multiple Results Loops often produce a different result for each iteration. If you want to save more than one result, there are a few things you must do. First, set up an index vector. The index vector should usually be congruent to the number of iterations or the input. The seq_along function returns a congruent index vector when passed a vector or list. For instance, let’s make in index for the numbers vector from Section 4.1.1: index = seq_along(numbers) The loop will iterate over the index rather than the input, so the induction variable will track the current iteration number. On the first iteration, the induction variable will be 1, on the second it will be 2, and so on. Then you can use the induction variable and indexing to get the input for each iteration. Second, set up an empty output vector or list. This should usually be congruent to the input, or one element longer (the extra element comes from the initial value). R has several functions for creating vectors. We’ve already seen a few, but here are more: logical, integer, numeric, complex, and character to create an empty vector with a specific type and length vector to create an empty vector with a specific type and length rep to create a vector by repeating elements of some other vector Empty vectors are filled with FALSE, 0, or \"\", depending on the type of the vector. Here are some examples: logical(3) ## [1] FALSE FALSE FALSE numeric(4) ## [1] 0 0 0 0 rep(c(1, 2), 2) ## [1] 1 2 1 2 Let’s create an empty numeric vector congruent to numbers: n = length(numbers) result = numeric(n) As with the input, you can use the induction variable and indexing to set the output for each iteration. Creating a vector or list in advance to store something, as we’ve just done, is called preallocation. Preallocation is extremely important for efficiency in loops. Avoid the temptation to use c or append to build up the output bit by bit in each iteration. Finally, write the loop, making sure to get the input and set the output. Here’s the loop for the squared sums example: for (i in index) { prev = if (i &gt; 1) result[i - 1] else 0 result[i] = (numbers[i] + prev)^2 } result ## [1] 1 4 1 9 4.1.4 Break &amp; Next The break keyword causes a loop to immediately exit. It only makes sense to use break inside of an if-statement. For example, suppose we want to print each string in a vector, but stop at the first missing value. We can do this with break: my_messages = c(&quot;Hi&quot;, &quot;Hello&quot;, NA, &quot;Goodbye&quot;) for (msg in my_messages) { if (is.na(msg)) break message(msg) } ## Hi ## Hello The next keyword causes a loop to immediately go to the next iteration. As with break, it only makes sense to use next inside of an if-statement. Let’s modify the previous example so that missing values are skipped, but don’t cause printing to stop. Here’s the code: for (msg in my_messages) { if (is.na(msg)) next message(msg) } ## Hi ## Hello ## Goodbye These keywords work with both for-loops and while-loops. 4.1.5 Example: The Collatz Conjecture The Collatz Conjecture is a conjecture in math that was introduced in 1937 by Lothar Collatz and remains unproven today, despite being relatively easy to explain. Here’s a statement of the conjecture: Start from any positive integer. If the integer is even, divide by 2. If the integer is odd, multiply by 3 and add 1. If the result is not 1, repeat using the result as the new starting value. The result will always reach 1 eventually, regardless of the starting value. The sequences of numbers this process generates are called Collatz sequences. For instance, the Collatz sequence starting from 2 is 2, 1. The Collatz sequence starting from 12 is 12, 6, 3, 10, 5, 16, 8, 4, 2, 1. As a final loop example, let’s use a while-loop to compute Collatz sequences. Here’s the code: n = 5 i = 0 while (n != 1) { i = i + 1 if (n %% 2 == 0) { n = n / 2 } else { n = 3 * n + 1 } message(paste0(n, &quot; &quot;)) } ## 16 ## 8 ## 4 ## 2 ## 1 As of 2020, scientists have used computers to check the Collatz sequences for every number up to approximately \\(2^{64}\\). For more details about the Collatz Conjecture, check out this video. 4.2 Planning for Iteration At first it may seem difficult to decide if and what kind of iteration to use. Start by thinking about whether you need to do something over and over. If you don’t, then you probably don’t need to use iteration. If you do, then try iteration strategies in this order: vectorization apply functions Try an apply function if iterations are independent. for/while-loops Try a for-loop if some iterations depend on others. Try a while-loop if the number of iterations is unknown. recursion (which isn’t covered here) Convenient for naturally recursive problems (like Fibonacci), but often there are faster solutions. Start by writing the code for just one iteration. Make sure that code works; it’s easy to test code for one iteration. When you have one iteration working, then try using the code with an iteration strategy (you will have to make some small changes). If it doesn’t work, try to figure out which iteration is causing the problem. One way to do this is to use message to print out information. Then try to write the code for the broken iteration, get that iteration working, and repeat this whole process. "],["references.html", "References", " References This reader would not have been possible without the many excellent reference texts created by other members of the R community. Now that you’ve completed this reader, these texts are a great way to continue you R learning journey. Advanced R by Hadley Wickham is a must-read if you want a deep understanding of R. It provides many examples of R features that are important for package/software development. Other texts I’ve found useful include: What They Forgot to Teach You About R by Bryan &amp; Hester. The Art of R Programming by Matloff (of UC Davis). A general reference on R programming, with more of a computer science and software engineering perspective than most R texts. The R Inferno by Burns. A discussion of the most difficult and confusing parts of R. R Packages by Wickham. A gentle, modern introduction to creating packages for R. Writing R Extensions by the R core developers. A description of how to create packages and other extensions for R. R Language Definition by the R core developers. Documentation about how R works at a low level. R Internals by the R core developers. Documentation about how R works internally (that is, its C code). Finally, here are a few other readers and notes created by DataLab staff: My personal teaching notes from several years of teaching statistical computing. R Basics, our workshop series aimed at people just starting to learn R. Adventures in Data Science, our course introducing humanities undergraduates to data science techniques. Python Basics, our workshop series aimed at people just starting to learn Python. Intermediate Python, this reader’s counterpart for Python users. "],["assessment.html", "Assessment", " Assessment If you are taking this workshop to complete a GradPathways Pathway, you can download the assessment instructions here. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
