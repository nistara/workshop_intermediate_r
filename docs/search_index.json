[["index.html", "Intermediate R Overview", " Intermediate R Nick Ulle 2023-01-16 Overview This is the reader for all of UC Davis DataLab’s Intermediate R workshop series. There are currently two: Thinking in R, which is about understanding how R works, how to diagnose and fix bugs in code, and how to estimate and measure performance characteristics of code. Cleaning Data &amp; Automating Tasks, which is about how to clean and prepare messy data such as dates, times, and text for analysis, and how to use loops or other forms of iteration to automate repetitive tasks. Each series is independent and consists of 2 sessions (equivalently, 2 chapters in this reader). After completing both series, students will have a better understanding of language features, packages, and programming strategies, which will enable them to write more efficient code, be more productive when writing code, and debug code more effectively. These series are not an introduction to R. Participants are expected to have prior experience using R, be comfortable with basic R syntax, and to have it pre-installed and running on their laptops. They are appropriate for motivated intermediate to advanced users who want a better understanding of base R. "],["language-fundamentals.html", "1 Language Fundamentals 1.1 Variables &amp; Environments 1.2 Closures 1.3 Attributes 1.4 S3 1.5 Other Object Systems", " 1 Language Fundamentals This chapter is part 1 (of 2) of Thinking in R, a workshop series about how R works and how to examine code critically. The major topics of this chapter are how R stores and locates variables (including functions) defined in your code and in packages, and how some of R’s object-oriented programming systems work. Learning Objectives Explain what an environment is and how R uses them Explain how R looks up variables Explain what attributes are and how R uses them Get and set attributes Explain what (S3) classes are and how R uses them Explain R’s (S3) method dispatch system Create an (S3) class Describe R’s other object-oriented programming systems at a high level 1.1 Variables &amp; Environments Assigning and looking up values of variables are fundamental operations in R, as in most programming languages. They were likely among the first operations you learned, and now you use them instictively. This section is a deep dive into what R actually does when you assign a variables and how R looks up the values of those variables later. Understanding the process and the data structures involved will introduce you to new programming strategies, make it easier to reason about code, and help you identify potential bugs. 1.1.1 What’s an Environment? The foundation of how R stores and looks up variables is a data structure called an environment. Every environment has two parts: A frame, which is a collection of names and associated R objects. A parent or enclosing environment, which must be another environment. For now, you’ll learn how to create environments and how to assign and get values from their frames. Parent environments will be explained in a later section. You can use the new.env function to create a new environment: e = new.env() e ## &lt;environment: 0x55643f38dec0&gt; Unlike most objects, printing an environment doesn’t print its contents. Instead, R prints its type (which is environment) and a unique identifier (0x55643f38dec0 in this case). The unique identifier is actually the memory address of the environment. Every object you use in R is stored as a series of bytes in your computer’s random-access memory (RAM). Each byte in memory has a unique address, similar to how each house on a street has a unique address. Memory addresses are usually just numbers counting up from 0, but they’re often written in hexadecimal (base 16) (indicated by the prefix 0x) because it’s more concise. For the purposes of this reader, you can just think of the memory address as a unique identifier. To see the names in an environment’s frame, you can call the ls or names function on the environment: ls(e) ## character(0) names(e) ## character(0) You just created the environment e, so its frame is currently empty. The printout character(0) means R returned a character vector of length 0. You can assign an R object to a name in an environment’s frame with the dollar sign $ operator or the double square bracket [[ operator, similar to how you would assign a named element of a list. For example, one way to assign the number 8 to the name \"lucky\" in the environment e’s frame is: e$lucky = 8 Now there’s a name defined in the environment: ls(e) ## [1] &quot;lucky&quot; names(e) ## [1] &quot;lucky&quot; Here’s another example of assigning an object to a name in the environment: e[[&quot;my_message&quot;]] = &quot;May your coffee kick in before reality does.&quot; You can assign any type of R object to a name in an environment, including other environments. The ls function ignores names that begin with a dot . by default. For example: e$.x = list(1, sin) ls(e) ## [1] &quot;lucky&quot; &quot;my_message&quot; You can pass the argument all.names = TRUE to make the function return all names in the frame: ls(e, all.names = TRUE) ## [1] &quot;.x&quot; &quot;lucky&quot; &quot;my_message&quot; Alternatively, you can just use the names function, which always prints all names in an environment’s frame. Objects in an environment’s frame don’t have positions or any particular order, so they must always be assigned to a name. R raises an error if you try to assign an object to a position: e[[3]] = 10 ## Error in e[[3]] = 10: wrong args for environment subassignment As you might expect, you can also use the dollar sign operator and double square bracket operator to get objects in an environment by name: e$my_message ## [1] &quot;May your coffee kick in before reality does.&quot; e[[&quot;lucky&quot;]] ## [1] 8 You can use the exists function to check whether a specific name exists in an environment’s frame: exists(&quot;hi&quot;, e) ## [1] FALSE exists(&quot;lucky&quot;, e) ## [1] TRUE Finally, you can remove a name and object from an environment’s frame with the rm function. Make sure to pass the environment as the argument to the envir parameter when you do this: rm(&quot;lucky&quot;, envir = e) exists(&quot;lucky&quot;, e) ## [1] FALSE 1.1.2 Reference Objects Environments are reference objects, which means they don’t follow R’s copy-on-write rule: for most types of objects, if you modify the object, R automatically and silently makes a copy, so that any other variables that refer to the object remain unchanged. As an example, lists follow the copy-on-write rule. Suppose you assign a list to variable x, assign x to y, and then make a change to x: x = list() x$a = 10 x ## $a ## [1] 10 y = x x$a = 20 y ## $a ## [1] 10 When you run y = x, R makes y refer to the same object as x, without using any additional memory. When you run x$a = 20, the copy-on-write rule applies, so R creates and modifies a copy of the object. From then on, x refers to the modified copy and y refers to the original. Environments don’t follow the copy-on-write rule, so repeating the example with an enviroment produces a different result: e_x = new.env() e_x$a = 10 e_x$a ## [1] 10 e_y = e_x e_x$a = 20 e_y$a ## [1] 20 As before, e_y = e_x makes both e_y and e_x refer to the same object. The difference is that when you run e_x$a = 20, the copy-on-write rule does not apply and R does not create a copy of the environment. As a result, the change to e_x is also reflected in e_y. Environments and other reference objects can be confusing since they behave differently from most objects. You usually won’t need to construct or manipulate environments directly, but it’s useful to know how to inspect them. 1.1.3 The Local Environment Think of environments as containers for variables. Whenever you assign a variable, R assigns it to the frame of an environment. Whenever you get a variable, R searches through one or more environments for its value. When you start R, R creates a special environment called the global environment to store variables you assign at the prompt or the top level of a script. You can use the globalenv function to get the global environment: g = globalenv() g ## &lt;environment: R_GlobalEnv&gt; The global environment is easy to recognize because its unique identifier is R_GlobalEnv rather than its memory address (even though it’s stored in your computer’s memory like any other object). The local environment is the environment where the assignment operators &lt;- and = assign variables. Think of the local environment as the environment that’s currently active. The local environment varies depending on the context where you run an expression. You can get the local environment with the environment function: loc = environment() loc ## &lt;environment: R_GlobalEnv&gt; As you can see, at the R prompt or the top level of an R script, the local environment is just the global environment. Except for names, the functions introduced in Section 1.1.1 default to the local environment if you don’t set the envir parameter. This makes them convenient for inspecting or modifying the local environment’s frame: ls(loc) ## [1] &quot;e&quot; &quot;e_x&quot; &quot;e_y&quot; &quot;g&quot; &quot;loc&quot; &quot;x&quot; &quot;y&quot; ls() ## [1] &quot;e&quot; &quot;e_x&quot; &quot;e_y&quot; &quot;g&quot; &quot;loc&quot; &quot;x&quot; &quot;y&quot; If you assign a variable, it appears in the local environment’s frame: coffee = &quot;Right. No coffee. This is a terrible planet.&quot; ls() ## [1] &quot;coffee&quot; &quot;e&quot; &quot;e_x&quot; &quot;e_y&quot; &quot;g&quot; &quot;loc&quot; &quot;x&quot; &quot;y&quot; loc$coffee ## [1] &quot;Right. No coffee. This is a terrible planet.&quot; Conversely, if you assign an object in the local environment’s frame, you can access it as a variable: loc$tea = &quot;Tea isn&#39;t coffee!&quot; tea ## [1] &quot;Tea isn&#39;t coffee!&quot; 1.1.4 Call Environments Every time you call (not define) a function, R creates a new environment. R uses this call environment as the local environment while the code in the body of the function runs. As a result, assigning variables in a function doesn’t affect the global environment, and they generally can’t be accessed from outside of the function. For example, consider this function which assigns the variable hello: my_hello = function() { hello = &quot;from the other side&quot; } Even after calling the function, there’s no variable hello in the global environment: my_hello() names(g) ## [1] &quot;loc&quot; &quot;my_hello&quot; &quot;tea&quot; &quot;e_x&quot; &quot;x&quot; &quot;e_y&quot; ## [7] &quot;y&quot; &quot;coffee&quot; &quot;e&quot; &quot;g&quot; &quot;.First&quot; As further demonstration, consider this modified version of my_hello, which returns the call environment: my_hello = function() { hello = &quot;from the other side&quot; environment() } The call environment is not the global environment: e = my_hello() e ## &lt;environment: 0x55644156a540&gt; And the variable hello exists in the call environment, but not in the global environment: exists(&quot;hello&quot;, g) ## [1] FALSE exists(&quot;hello&quot;, e) ## [1] TRUE e$hello ## [1] &quot;from the other side&quot; Each call to a function creates a new call environment. So if you call my_hello again, it returns a different environment (pay attention to the memory address): e2 = my_hello() e ## &lt;environment: 0x55644156a540&gt; e2 ## &lt;environment: 0x5564419b93f8&gt; By creating a new environment for every call, R isolates code in the function body from code outside of the body. As a result, most R functions have no side effects. This is a good thing, since it means you generally don’t have to worry about calls assigning, reassigning, or removing variables in other environments (such as the global environment!). The local function provides another way to create a new local environment in which to run code. However, it’s usually preferable to define and call a function, since that makes it easier to test and reuse the code. 1.1.5 Lexical Scoping A function can access variables outside of its local environment, but only if those variables exist in the environment where the function was defined (not called). This property is called lexical scoping. For example, assign a variable tea and function get_tea in the global environment: tea = &quot;Tea isn&#39;t coffee!&quot; get_tea = function() { tea } Then the get_tea function can access the tea variable: get_tea() ## [1] &quot;Tea isn&#39;t coffee!&quot; Note that variable lookup takes place when a function is called, not when it’s defined. This is called dynamic lookup. For example, the result from get_tea changes if you change the value of tea: tea = &quot;Tea for two.&quot; get_tea() ## [1] &quot;Tea for two.&quot; tea = &quot;Tea isn&#39;t coffee!&quot; get_tea() ## [1] &quot;Tea isn&#39;t coffee!&quot; When a local variable (a variable in the local environment) and a non-local variable have the same name, R almost always prioritizes the local variable. For instance: get_local_tea = function() { tea = &quot;Earl grey is tea!&quot; tea } get_local_tea() ## [1] &quot;Earl grey is tea!&quot; The function body assigns the local variable tea to \"Earl grey is tea!\", so R returns that value rather than \"Tea isn't coffee!\". In other words, local variables mask, or hide, non-local variables with the same name. There’s only one case where R doesn’t prioritize local variables. To see it, consider this call: mean(1:20) ## [1] 10.5 The variable mean must refer to a function, because it’s being called—it’s followed by parentheses ( ), the call syntax. In this situation, R ignores local variables that aren’t functions, so you can write code such as: mean = 10 mean(1:10) ## [1] 5.5 That said, defining a local variable with the same name as a function can still be confusing, so it’s usually considered a bad practice. To help you reason about lexical scoping, you can get the environment where a function was defined by calling the environment function on the function itself. For example, the get_tea function was defined in the global environment: environment(get_tea) ## &lt;environment: R_GlobalEnv&gt; 1.1.6 Variable Lookup The key to how R looks up variables and how lexical scoping works is that in addition to a frame, every environment has a parent environment. When R evaluates a variable in an expression, it starts by looking for the variable in the local environment’s frame. For example, at the prompt, tea is a local variable because that’s where you assigned it. If you enter tea at the prompt, R finds tea in the local environment’s frame and returns the value: tea ## [1] &quot;Tea isn&#39;t coffee!&quot; On the other hand, in the get_tea function from Section 1.1.5, tea is not a local variable: get_tea = function() { tea } To make this more concrete, consider a function which just returns its call environment: get_call_env = function() { environment() } The call environment clearly doesn’t contain the tea variable: e = get_call_env() ls(e) ## character(0) When a variable doesn’t exist in the local environment’s frame, then R gets the parent environment of the local environment. You can use the parent.env function to get the parent environment of an environment. For the call environment e, the parent environment is the global environment, because that’s where get_call_env was defined: parent.env(e) ## &lt;environment: R_GlobalEnv&gt; When R can’t find tea in the call environment’s frame, R gets the parent environment, which is the global environment. Then R searches for tea in the global environment, finds it, and returns the value. R repeats the lookup process for as many parents as necessary to find the variable, stopping only when it finds the variable or a special environment called the empty environment which will be explained in Section 1.1.7. The lookup process also hints at how R finds variables and functions such as pi and sqrt that clearly aren’t defined in the global environment. They’re defined in parent environments of the global environment. The get function looks up a variable by name: get(&quot;pi&quot;) ## [1] 3.141593 You can use the get function to look up a variable starting from a specific environment or to control how R does the lookup the variable. For example, if you set inherits = FALSE, R will not search any parent environments: get(&quot;pi&quot;, inherits = FALSE) ## Error in get(&quot;pi&quot;, inherits = FALSE): object &#39;pi&#39; not found As with most functions for inspecting and modifying environments, use the get function sparingly. R already provides a much simpler way to get a variable: the variable’s name. 1.1.7 The Search Path R also uses environments to manage packages. Each time you load a package with library or require, R creates a new environment: The frame contains the package’s local variables. The parent environment is the environment of the previous package loaded. This new environment becomes the parent of the global environment. R always loads several built-in packages at startup, which contain variables and functions such as pi and sqrt. Thus the global environment is never the top-level environment. For instance: g = globalenv() e = parent.env(g) e ## &lt;environment: package:stats&gt; ## attr(,&quot;name&quot;) ## [1] &quot;package:stats&quot; ## attr(,&quot;path&quot;) ## [1] &quot;/usr/lib/R/library/stats&quot; e = parent.env(e) e ## &lt;environment: package:graphics&gt; ## attr(,&quot;name&quot;) ## [1] &quot;package:graphics&quot; ## attr(,&quot;path&quot;) ## [1] &quot;/usr/lib/R/library/graphics&quot; Notice that package environments use package: and the name of the package as their unique identifier rather than their memory address. The chain of package environments is called the search path. The search function returns the search path: search() ## [1] &quot;.GlobalEnv&quot; &quot;package:stats&quot; &quot;package:graphics&quot; ## [4] &quot;package:grDevices&quot; &quot;package:utils&quot; &quot;package:datasets&quot; ## [7] &quot;package:methods&quot; &quot;Autoloads&quot; &quot;package:base&quot; The base environment (identified by base) is the always topmost environment. You can use the baseenv function to get the base environment: baseenv() ## &lt;environment: base&gt; The base environment’s parent is the special empty environment (identified by R_EmptyEnv), which contains no variables and has no parent. You can use the emptyenv function to get the empty environment: emptyenv() ## &lt;environment: R_EmptyEnv&gt; Understanding R’s process for looking up variables and the search path is helpful for resolving conflicts between the names of variables in packages. 1.1.7.1 The Colon Operators The double-colon operator :: gets a variable in a specific package. Two common uses: Disambiguate which package you mean when several packages have variables with the same names. Get a variable from a package without loading the package. For example: library(dplyr) ## Registered S3 methods overwritten by &#39;tibble&#39;: ## method from ## format.tbl pillar ## print.tbl pillar ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union stats::filter ## function (x, filter, method = c(&quot;convolution&quot;, &quot;recursive&quot;), ## sides = 2L, circular = FALSE, init = NULL) ## { ## method &lt;- match.arg(method) ## x &lt;- as.ts(x) ## storage.mode(x) &lt;- &quot;double&quot; ## xtsp &lt;- tsp(x) ## n &lt;- as.integer(NROW(x)) ## if (is.na(n)) ## stop(gettextf(&quot;invalid value of %s&quot;, &quot;NROW(x)&quot;), domain = NA) ## nser &lt;- NCOL(x) ## filter &lt;- as.double(filter) ## nfilt &lt;- as.integer(length(filter)) ## if (is.na(nfilt)) ## stop(gettextf(&quot;invalid value of %s&quot;, &quot;length(filter)&quot;), ## domain = NA) ## if (anyNA(filter)) ## stop(&quot;missing values in &#39;filter&#39;&quot;) ## if (method == &quot;convolution&quot;) { ## if (nfilt &gt; n) ## stop(&quot;&#39;filter&#39; is longer than time series&quot;) ## sides &lt;- as.integer(sides) ## if (is.na(sides) || (sides != 1L &amp;&amp; sides != 2L)) ## stop(&quot;argument &#39;sides&#39; must be 1 or 2&quot;) ## circular &lt;- as.logical(circular) ## if (is.na(circular)) ## stop(&quot;&#39;circular&#39; must be logical and not NA&quot;) ## if (is.matrix(x)) { ## y &lt;- matrix(NA, n, nser) ## for (i in seq_len(nser)) y[, i] &lt;- .Call(C_cfilter, ## x[, i], filter, sides, circular) ## } ## else y &lt;- .Call(C_cfilter, x, filter, sides, circular) ## } ## else { ## if (missing(init)) { ## init &lt;- matrix(0, nfilt, nser) ## } ## else { ## ni &lt;- NROW(init) ## if (ni != nfilt) ## stop(&quot;length of &#39;init&#39; must equal length of &#39;filter&#39;&quot;) ## if (NCOL(init) != 1L &amp;&amp; NCOL(init) != nser) { ## stop(sprintf(ngettext(nser, &quot;&#39;init&#39; must have %d column&quot;, ## &quot;&#39;init&#39; must have 1 or %d columns&quot;, domain = &quot;R-stats&quot;), ## nser), domain = NA) ## } ## if (!is.matrix(init)) ## dim(init) &lt;- c(nfilt, nser) ## } ## ind &lt;- seq_len(nfilt) ## if (is.matrix(x)) { ## y &lt;- matrix(NA, n, nser) ## for (i in seq_len(nser)) y[, i] &lt;- .Call(C_rfilter, ## x[, i], filter, c(rev(init[, i]), double(n)))[-ind] ## } ## else y &lt;- .Call(C_rfilter, x, filter, c(rev(init[, 1L]), ## double(n)))[-ind] ## } ## tsp(y) &lt;- xtsp ## class(y) &lt;- if (nser &gt; 1L) ## c(&quot;mts&quot;, &quot;ts&quot;) ## else &quot;ts&quot; ## y ## } ## &lt;bytecode: 0x5564401af1f8&gt; ## &lt;environment: namespace:stats&gt; dplyr::filter ## function (.data, ..., .preserve = FALSE) ## { ## UseMethod(&quot;filter&quot;) ## } ## &lt;bytecode: 0x55644062d420&gt; ## &lt;environment: namespace:dplyr&gt; ggplot2::ggplot ## function (data = NULL, mapping = aes(), ..., environment = parent.frame()) ## { ## UseMethod(&quot;ggplot&quot;) ## } ## &lt;bytecode: 0x55643ed42860&gt; ## &lt;environment: namespace:ggplot2&gt; The related triple-colon operator ::: gets a private variable in a package. Generally these are private for a reason! Only use ::: if you’re sure you know what you’re doing. 1.2 Closures A closure is a function together with an enclosing environment. In order to support lexical scoping, every R function is a closure (except a few very special built-in functions). The enclosing environment is generally the environment where the function was defined. Recall that you can use the environment function to get the enclosing environment of a function: f = function() 42 environment(f) ## &lt;environment: R_GlobalEnv&gt; Since the enclosing environment exists whether or not you call the function, you can use the enclosing environment to store and share data between calls. You can use the superassignment operator &lt;&lt;- to assign to a variable to an ancestor environment (if the variable already exists) or the global environment (if the variable does not already exist). For example, suppose you want to make a function that returns the number of times it’s been called: counter = 0 count = function() { counter &lt;&lt;- counter + 1 counter } In this example, the enclosing environment is the global environment. Each time you call count, it assigns a new value to the counter variable in the global environment. 1.2.1 Tidy Closures The count function has a side effect—it reassigns a non-local variable. As discussed in 1.1.4, functions with side effects make code harder to understand and reason about. Use side effects sparingly and try to isolate them from the global environment. When side effects aren’t isolated, several things can go wrong. The function might overwrite the user’s variables: counter = 0 count() ## [1] 1 Or the user might overwrite the function’s variables: counter = &quot;hi&quot; count() ## Error in counter + 1: non-numeric argument to binary operator For functions that rely on storing information in their enclosing environment, there are several different ways to make sure the enclosing environment is isolated. Two of these are: Define and return the function from the body of another function. The second function is called a factory function because it produces (returns) the first. The enclosing environment of the first function is the call environment of the second. Define the function inside of a call to local. Here’s a template for the first approach: make_fn = function() { # Define variables in the enclosing environment here: # Define and return the function here: function() { # ... } } f = make_fn() # Now you can call f() as you would any other function. For example, you can use the template for the counter function: make_count = function() { counter = 0 function() { counter &lt;&lt;- counter + 1 counter } } count = make_count() Then calling count has no effect on the global environment: counter = 10 count() ## [1] 1 counter ## [1] 10 1.3 Attributes An attribute is named metadata attached to an R object. Attributes provide basic information about objects and play an important role in R’s class system, so most objects have attributes. Some common attributes are: class – the class row.names – row names names – element names or column names dim – dimensions (on matrices) dimnames – names of dimensions (on matrices) R provides helper functions to get and set the values of the common attributes. These functions usually have the same name as the attribute. For example, the class function gets or sets the class attribute: class(mtcars) ## [1] &quot;data.frame&quot; row.names(mtcars) ## [1] &quot;Mazda RX4&quot; &quot;Mazda RX4 Wag&quot; &quot;Datsun 710&quot; ## [4] &quot;Hornet 4 Drive&quot; &quot;Hornet Sportabout&quot; &quot;Valiant&quot; ## [7] &quot;Duster 360&quot; &quot;Merc 240D&quot; &quot;Merc 230&quot; ## [10] &quot;Merc 280&quot; &quot;Merc 280C&quot; &quot;Merc 450SE&quot; ## [13] &quot;Merc 450SL&quot; &quot;Merc 450SLC&quot; &quot;Cadillac Fleetwood&quot; ## [16] &quot;Lincoln Continental&quot; &quot;Chrysler Imperial&quot; &quot;Fiat 128&quot; ## [19] &quot;Honda Civic&quot; &quot;Toyota Corolla&quot; &quot;Toyota Corona&quot; ## [22] &quot;Dodge Challenger&quot; &quot;AMC Javelin&quot; &quot;Camaro Z28&quot; ## [25] &quot;Pontiac Firebird&quot; &quot;Fiat X1-9&quot; &quot;Porsche 914-2&quot; ## [28] &quot;Lotus Europa&quot; &quot;Ford Pantera L&quot; &quot;Ferrari Dino&quot; ## [31] &quot;Maserati Bora&quot; &quot;Volvo 142E&quot; An attribute can have any name and any value. You can use the attr function to get or set an attribute by name: attr(mtcars, &quot;row.names&quot;) ## [1] &quot;Mazda RX4&quot; &quot;Mazda RX4 Wag&quot; &quot;Datsun 710&quot; ## [4] &quot;Hornet 4 Drive&quot; &quot;Hornet Sportabout&quot; &quot;Valiant&quot; ## [7] &quot;Duster 360&quot; &quot;Merc 240D&quot; &quot;Merc 230&quot; ## [10] &quot;Merc 280&quot; &quot;Merc 280C&quot; &quot;Merc 450SE&quot; ## [13] &quot;Merc 450SL&quot; &quot;Merc 450SLC&quot; &quot;Cadillac Fleetwood&quot; ## [16] &quot;Lincoln Continental&quot; &quot;Chrysler Imperial&quot; &quot;Fiat 128&quot; ## [19] &quot;Honda Civic&quot; &quot;Toyota Corolla&quot; &quot;Toyota Corona&quot; ## [22] &quot;Dodge Challenger&quot; &quot;AMC Javelin&quot; &quot;Camaro Z28&quot; ## [25] &quot;Pontiac Firebird&quot; &quot;Fiat X1-9&quot; &quot;Porsche 914-2&quot; ## [28] &quot;Lotus Europa&quot; &quot;Ford Pantera L&quot; &quot;Ferrari Dino&quot; ## [31] &quot;Maserati Bora&quot; &quot;Volvo 142E&quot; attr(mtcars, &quot;foo&quot;) = 42 attr(mtcars, &quot;foo&quot;) ## [1] 42 You can get all of the attributes attached to an object with the attributes function: attributes(mtcars) ## $names ## [1] &quot;mpg&quot; &quot;cyl&quot; &quot;disp&quot; &quot;hp&quot; &quot;drat&quot; &quot;wt&quot; &quot;qsec&quot; &quot;vs&quot; &quot;am&quot; &quot;gear&quot; ## [11] &quot;carb&quot; ## ## $row.names ## [1] &quot;Mazda RX4&quot; &quot;Mazda RX4 Wag&quot; &quot;Datsun 710&quot; ## [4] &quot;Hornet 4 Drive&quot; &quot;Hornet Sportabout&quot; &quot;Valiant&quot; ## [7] &quot;Duster 360&quot; &quot;Merc 240D&quot; &quot;Merc 230&quot; ## [10] &quot;Merc 280&quot; &quot;Merc 280C&quot; &quot;Merc 450SE&quot; ## [13] &quot;Merc 450SL&quot; &quot;Merc 450SLC&quot; &quot;Cadillac Fleetwood&quot; ## [16] &quot;Lincoln Continental&quot; &quot;Chrysler Imperial&quot; &quot;Fiat 128&quot; ## [19] &quot;Honda Civic&quot; &quot;Toyota Corolla&quot; &quot;Toyota Corona&quot; ## [22] &quot;Dodge Challenger&quot; &quot;AMC Javelin&quot; &quot;Camaro Z28&quot; ## [25] &quot;Pontiac Firebird&quot; &quot;Fiat X1-9&quot; &quot;Porsche 914-2&quot; ## [28] &quot;Lotus Europa&quot; &quot;Ford Pantera L&quot; &quot;Ferrari Dino&quot; ## [31] &quot;Maserati Bora&quot; &quot;Volvo 142E&quot; ## ## $class ## [1] &quot;data.frame&quot; ## ## $foo ## [1] 42 You can use the structure function to set multiple attributes on an object: mod_mtcars = structure(mtcars, foo = 50, bar = 100) attributes(mod_mtcars) ## $names ## [1] &quot;mpg&quot; &quot;cyl&quot; &quot;disp&quot; &quot;hp&quot; &quot;drat&quot; &quot;wt&quot; &quot;qsec&quot; &quot;vs&quot; &quot;am&quot; &quot;gear&quot; ## [11] &quot;carb&quot; ## ## $row.names ## [1] &quot;Mazda RX4&quot; &quot;Mazda RX4 Wag&quot; &quot;Datsun 710&quot; ## [4] &quot;Hornet 4 Drive&quot; &quot;Hornet Sportabout&quot; &quot;Valiant&quot; ## [7] &quot;Duster 360&quot; &quot;Merc 240D&quot; &quot;Merc 230&quot; ## [10] &quot;Merc 280&quot; &quot;Merc 280C&quot; &quot;Merc 450SE&quot; ## [13] &quot;Merc 450SL&quot; &quot;Merc 450SLC&quot; &quot;Cadillac Fleetwood&quot; ## [16] &quot;Lincoln Continental&quot; &quot;Chrysler Imperial&quot; &quot;Fiat 128&quot; ## [19] &quot;Honda Civic&quot; &quot;Toyota Corolla&quot; &quot;Toyota Corona&quot; ## [22] &quot;Dodge Challenger&quot; &quot;AMC Javelin&quot; &quot;Camaro Z28&quot; ## [25] &quot;Pontiac Firebird&quot; &quot;Fiat X1-9&quot; &quot;Porsche 914-2&quot; ## [28] &quot;Lotus Europa&quot; &quot;Ford Pantera L&quot; &quot;Ferrari Dino&quot; ## [31] &quot;Maserati Bora&quot; &quot;Volvo 142E&quot; ## ## $class ## [1] &quot;data.frame&quot; ## ## $foo ## [1] 50 ## ## $bar ## [1] 100 Vectors usually don’t have attributes: attributes(5) ## NULL But the class function still returns a class: class(5) ## [1] &quot;numeric&quot; When a helper function exists to get or set an attribute, use the helper function rather than attr. This will make your code clearer and ensure that attributes with special behavior and requirements, such as dim, are set correctly. 1.4 S3 R provides several systems for object-oriented programming (OOP), a programming paradigm where code is organized into a collection of “objects” that interact with each other. These systems provide a way to create new data structures with customized behavior, and also underpin how some of R’s built-in functions work. The S3 system is particularly important for understanding R, because it’s the oldest and most widely-used. This section focuses on S3, while Section 1.5 provides an overview of R’s other OOP systems. The central idea of S3 is that some functions can be generic, meaning they perform different computations (and run different code) for different classes of objects. Conversely, every object has at least one class, which dictates how the object behaves. For most objects, the class is independent of type and is stored in the class attribute. You can get the class of an object with the class function. For example, the class of a data frame is data.frame: class(mtcars) ## [1] &quot;data.frame&quot; Some objects have more than one class. One example of this is matrices: m = matrix() class(m) ## [1] &quot;matrix&quot; &quot;array&quot; When an object has multiple classes, they’re stored in the class attribute in order from highest to lowest priority. So the matrix m will primarily behave like a matrix, but it can also behave like an array. The priority of classes is often described in terms of a child-parent relationship: array is the parent class of matrix, or equivalently, the class matrix inherits from the class array. 1.4.1 Method Dispatch A function is generic if it selects and calls another function, called a method, based on the class of one of its arguments. A generic function can have any number of methods, and each must have the same signature, or collection of parameters, as the generic. Think of a generic function’s methods as the range of different computations it can perform, or alternatively as the range of different classes it can accept as input. Method dispatch, or just dispatch, is the process of selecting a method based on the class of an argument. You can identify S3 generics because they always call the UseMethod function, which initiates S3 method dispatch. Many of R’s built-in functions are generic. One example is the split function, which splits a data frame or vector into groups: split ## function (x, f, drop = FALSE, ...) ## UseMethod(&quot;split&quot;) ## &lt;bytecode: 0x55643ce55938&gt; ## &lt;environment: namespace:base&gt; Another is the plot function, which creates a plot: plot ## function (x, y, ...) ## UseMethod(&quot;plot&quot;) ## &lt;bytecode: 0x55644147f598&gt; ## &lt;environment: namespace:base&gt; The UseMethod function requires the name of the generic (as a string) as its first argument. The second argument is optional and specifies the object to use for method dispatch. By default, the first argument to the generic is used for method dispatch. So for split, the argument for x is used for method dispatch. R checks the class of the argument and selects a matching method. You can use the methods function to list all of the methods of a generic. The methods for split are: methods(split) ## [1] split.data.frame split.Date split.default split.POSIXct ## see &#39;?methods&#39; for accessing help and source code Method names always have the form GENERIC.CLASS, where GENERIC is the name of the generic and CLASS is the name of a class. For instance, split.data.frame is the split method for objects with class data.frame. Methods named GENERIC.default are a special case: they are default methods, selected only if none of the other methods match the class during dispatch. So split.default is the default method for split. Most generic functions have a default method. Methods are ordinary R functions. For instance, the code for split.data.frame is: split.data.frame ## function (x, f, drop = FALSE, ...) ## { ## if (inherits(f, &quot;formula&quot;)) ## f &lt;- eval(attr(stats::terms(f), &quot;variables&quot;), x, environment(f)) ## lapply(split(x = seq_len(nrow(x)), f = f, drop = drop, ...), ## function(ind) x[ind, , drop = FALSE]) ## } ## &lt;bytecode: 0x55643eea5da8&gt; ## &lt;environment: namespace:base&gt; Sometimes methods are defined in privately packages and can’t be accessed by typing their name at the prompt. You can use the getAnywhere function to get the code for these methods. For instance, to get the code for plot.data.frame: getAnywhere(plot.data.frame) ## A single object matching &#39;plot.data.frame&#39; was found ## It was found in the following places ## registered S3 method for plot from namespace graphics ## namespace:graphics ## with value ## ## function (x, ...) ## { ## plot2 &lt;- function(x, xlab = names(x)[1L], ylab = names(x)[2L], ## ...) plot(x[[1L]], x[[2L]], xlab = xlab, ylab = ylab, ## ...) ## if (!is.data.frame(x)) ## stop(&quot;&#39;plot.data.frame&#39; applied to non data frame&quot;) ## if (ncol(x) == 1) { ## x1 &lt;- x[[1L]] ## if (class(x1)[1L] %in% c(&quot;integer&quot;, &quot;numeric&quot;)) ## stripchart(x1, ...) ## else plot(x1, ...) ## } ## else if (ncol(x) == 2) { ## plot2(x, ...) ## } ## else { ## pairs(data.matrix(x), ...) ## } ## } ## &lt;bytecode: 0x55643e8e9bc8&gt; ## &lt;environment: namespace:graphics&gt; As a demonstration of method dispatch, consider this code to split the mtcars dataset by number of cylinders: split(mtcars, mtcars$cyl) The split function is generic and dispatches on its first argument. In this case, the first argument is mtcars, which has class data.frame. Since the method split.data.frame exists, R calls split.data.frame with the same arguments you used to call the generic split function. In other words, R calls: split.data.frame(mtcars, mtcars$cyl) When an object has more than one class, method dispatch considers them from left to right. For instance, matrices created with the matrix function have class matrix and also class array. If you pass a matrix to a generic function, R will first look for a matrix method. If there isn’t one, R will look for an array method. If there still isn’t one, R will look for a default method. If there’s no default method either, then R raises an error. The sloop package provides useful functions inspecting S3 classes, generics, and methods, as well as the method dispatch process. For example, you can use the s3_dispatch function to see which method will be selected when you call a generic: # install.packages(&quot;sloop&quot;) library(&quot;sloop&quot;) s3_dispatch(split(mtcars, mtcars$cyl)) ## =&gt; split.data.frame ## * split.default The selected method is indicated with an arrow =&gt;, while methods that were not selected are indicated with a star *. See ?s3_dispatch for complete details about the output from the function. 1.4.2 Creating Objects S3 classes are defined implicitly by their associated methods. To create a new class, decide what its structure will be and define some methods. To create an object of the class, set an object’s class attribute to the class name. For example, let’s create a generic function get_age that returns the age of an animal in terms of a typical human lifespan. First define the generic: get_age = function(animal) { UseMethod(&quot;get_age&quot;) } Next, let’s create a class Human to represent a human. Since humans are animals, let’s make each Human also have class Animal. You can use any type of object as the foundation for a class, but lists are often a good choice because they can store multiple named elements. Here’s how to create a Human object with a field age_years to store the age in years: lyra = list(age_years = 13) class(lyra) = c(&quot;Human&quot;, &quot;Animal&quot;) Class names can include any characters that are valid in R variable names. One common convention is to make them start with an uppercase letter, to distinguish them from variables. If you want to make constructing an object of a given class less ad-hoc (and error-prone), define a constructor function that returns a new object of a given class. A common convention is to give the constructor function the same name as the class: Human = function(age_years) { obj = list(age_years = age_years) class(obj) = c(&quot;Human&quot;, &quot;Animal&quot;) obj } asriel = Human(45) The get_age generic doesn’t have any methods yet, so R raises an error if you call it (regardless of the argument’s class): get_age(lyra) ## Error in UseMethod(&quot;get_age&quot;): no applicable method for &#39;get_age&#39; applied to an object of class &quot;c(&#39;Human&#39;, &#39;Animal&#39;)&quot; Let’s define a method for Animal objects. The method will just return the value of the age_years field: get_age.Animal = function(animal) { animal$age_years } get_age(lyra) ## [1] 13 get_age(asriel) ## [1] 45 Notice that the get_age generic still raises an error for objects that don’t have class Animal: get_age(3) ## Error in UseMethod(&quot;get_age&quot;): no applicable method for &#39;get_age&#39; applied to an object of class &quot;c(&#39;double&#39;, &#39;numeric&#39;)&quot; Now let’s create a class Dog to represent dogs. Like the Human class, a Dog is a kind of Animal and has an age_years field. Each Dog will also have a breed field to store the breed of the dog: Dog = function(age_years, breed) { obj = list(age_years = age_years, breed = breed) class(obj) = c(&quot;Dog&quot;, &quot;Animal&quot;) obj } pongo = Dog(10, &quot;dalmatian&quot;) Since a Dog is an Animal, the get_age generic returns a result: get_age(pongo) ## [1] 10 Recall that the goal of this example was to make get_age return the age of an animal in terms of a human lifespan. For a dog, their age in “human years” is about 5 times their age in actual years. You can implement a get_age method for Dog to take this into account: get_age.Dog = function(animal) { animal$age_years * 5 } Now the get_age generic returns an age in terms of a human lifespan whether its argument is a Human or a Dog: get_age(lyra) ## [1] 13 get_age(pongo) ## [1] 50 You can create new data structures in R by creating classes, and you can add functionality to new or existing generics by creating new methods. Before creating a class, think about whether R already provides a data structure that suits your needs. It’s uncommon to create new classes in the course of a typical data analysis, but many packages do provide new classes. Regardless of whether you ever create a new class, understanding the details means understanding how S3 works, and thus how R’s many S3 generic functions work. As a final note, while exploring S3 methods you may also encounter the NextMethod function. The NextMethod function redirects dispatch to the method that is the next closest match for an object’s class. You can learn more by reading ?NextMethod. 1.5 Other Object Systems R provides many systems for object-oriented programming besides S3. Some are built into the language, while others are provided by packages. A few of the most popular systems are: S4 – S4 is built into R and is the most widely-used system after S3. Like S3, S4 frames OOP in terms of generic functions and methods. The major differences are that S4 is stricter—the structure of each class must be formally defined—and that S4 generics can dispatch on the classes of multiple arguments instead of just one. R provides a special field operator @ to access fields of an S4 object. Most of the packages in the Bioconductor project use S4. Reference classes – Objects created with the S3 and S4 systems generally follow the copy-on-write rule, but this can be inefficient for some programming tasks. The reference class system is built into R and provides a way to create reference objects with a formal class structure (in the spirit of S4). This system is more like OOP systems in languages like Java and Python than S3 or S4 are. The reference class system is sometimes jokingly called “R5”, but that isn’t an official name. R6 – An alternative to reference classes created by Winston Chang, a developer at Posit (formerly RStudio). Claims to be simpler and faster than reference classes. R7 – A new OOP system being developed collaboratively by representatives from several different important groups in the R community, including the R core developers, Bioconductor, and Posit. Many of these systems are described in more detail in Hadley Wickham’s book Advanced R. "],["debugging.html", "2 Debugging 2.1 Printing Output 2.2 The Conditions System 2.3 Debugging Code 2.4 Profiling Code", " 2 Debugging This chapter is part 2 (of 2) of Thinking in R, a workshop series about how R works and how to examine code critically. The major topics of this chapter are how R prints output, how R’s conditions system for warnings and errors works, how to use the R debugger, and how to estimate the performance of R code. Learning Objectives Identify and explain the difference between R’s various printing functions Use R’s conditions system to raise and catch messages, warnings, and errors Use R’s debugging functions to diagnose bugs in code Estimate the amount of memory a data set will require Use the lobstr package to get memory usage for an R object Describe what a profiler is and why you would use one Describe what kinds of profiling tools R provides 2.1 Printing Output 2.2 The Conditions System 2.3 Debugging Code 2.4 Profiling Code "],["string-date-processing.html", "3 String &amp; Date Processing 3.1 The Tidyverse 3.2 Date Processing 3.3 Printing Output 3.4 Escape Sequences 3.5 Character Encodings 3.6 The stringr Package 3.7 Regular Expressions", " 3 String &amp; Date Processing 3.1 The Tidyverse The Tidyverse is a popular collection of packages for doing data science in R. The packages are made by many of the same people that make RStudio. They provide alternatives to R’s built-in tools for: Manipulating strings (package stringr) Making visualizations (package ggplot2) Reading files (package readr) Manipulating data frames (packages dplyr, tidyr, tibble) And more Think of the Tidyverse as a different dialect of R. Sometimes the syntax is different, and sometimes ideas are easier or harder to express concisely. Whether to use base R or the Tidyverse is mostly subjective. As a result, the Tidyverse is somewhat polarizing in the R community. It’s useful to be literate in both, since both are popular. One advantage of the Tidyverse is that the packages are usually well-documented. For example, there are documentation websites and cheat sheets for most Tidyverse packages. 3.2 Date Processing Besides strings, dates and times are another kind of data that require special attention to prepare for analysis. This is especially important if you want to do anything that involves sorting dates, like making a line plot with dates on one axis. Dates may not be sorted correctly if they haven’t been converted to one of R’s date classes. There several built-in functions and also many packages for date processing. As with visualization and string processing, the Tidyverse packages have the best combination of simple design and clear documentation. There are three Tidyverse packages for processing dates and times: lubridate, the primary package for working with dates and times hms, a package specifically for working with times clock, a new package for working with dates and times We’ll focus on the lubridate package. As always, you’ll have to install the package if you haven’t already, and then load it: # install.packages(&quot;lubridate&quot;) library(&quot;lubridate&quot;) ## ## Attaching package: &#39;lubridate&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## date, intersect, setdiff, union The most common task is to convert a string into a date or time class. For instance, when you load a data set, you might have dates that look like this: dates = c(&quot;Jan 10, 2021&quot;, &quot;Sep 3, 2018&quot;, &quot;Feb 28, 1982&quot;) dates ## [1] &quot;Jan 10, 2021&quot; &quot;Sep 3, 2018&quot; &quot;Feb 28, 1982&quot; These are strings, so it’s relatively difficult to sort the dates, do arithmetic on them, or extract just one part (such as the year). There are several lubridate functions to automatically convert strings into dates. They are named with one letter for each part of the date. For instance, the dates in the example have the month (m), then the day (d), and then the year (y), so we can use the mdy function: result = mdy(dates) result ## [1] &quot;2021-01-10&quot; &quot;2018-09-03&quot; &quot;1982-02-28&quot; class(result) ## [1] &quot;Date&quot; Notice that the dates now have class Date, one of R’s built-in classes for representing dates, and that they print differently. You can find a full list of the automatic string to date conversion functions in the lubridate documentation. Occasionally, a date string may have a format that lubridate can’t convert automatically. In that case, you can use the fast_strptime function to describe the format in detail. At a minimum, the function requires two arguments: the vector of strings to convert and a format string. The format string describes the format of the dates, and is based on the syntax of strptime, a function provided by many programming languages for converting strings to dates (including R). In a format string, a percent sign % followed by a character is called a specification and has a special meaning. Here are a few of the most useful ones: Specification Description January 29, 2015 %Y 4-digit year 2015 %y 2-digit year 15 %m 2-digit month 01 %B full month name January %b short month name Jan %d day of month 29 %% literal % % You can find a complete list in ?fast_strptime. Other characters in the format string do not have any special meaning. Write the format string so that it matches the format of the dates you want to convert. For example, let’s try converting an unusual time format: odd_time = &quot;6 minutes, 32 seconds after 10 o&#39;clock&quot; fast_strptime(odd_time, &quot;%M minutes, %S seconds after %H o&#39;clock&quot;) ## [1] &quot;0-01-01 10:06:32 UTC&quot; R usually represents dates with the class Date, and date-times with the classes POSIXct and POSIXlt. The difference between the two date-time classes is somewhat technical, but you can read more about it in ?POSIXlt. There is no built-in class to represent times alone, which is why the result in the example above includes a date. Nonetheless, the hms package provides the hms class to represent times without dates. Once you’ve converted a string to a date, the lubridate package provides a variety of functions to get or set the parts individually. Here are a few examples: day(result) ## [1] 10 3 28 month(result) ## [1] 1 9 2 You can find a complete list in the lubridate documentation. 3.2.1 Case Study: Correcting Dates 3.3 Printing Output The cat function prints a string in the R console. If you pass multiple arguments, they will be concatenated: cat(&quot;Hello&quot;) ## Hello cat(&quot;Hello&quot;, &quot;Nick&quot;) ## Hello Nick Pitfall 1: Printing a string is different from returning a string. The cat function only prints (and always returns NULL). For example: f = function() { cat(&quot;Hello&quot;) } x = f() ## Hello x ## NULL If you just want to concatenate some strings (but not necessarily print them), use paste instead of cat. The paste function returns a string. The str_c function in stringr (a package we’ll learn about later in this lesson) can also concatenate strings. Pitfall 2: Remember to print strings with the cat function, not the print function. The print function prints R’s representation of an object, the same as if you had entered the object in the console without calling print. For instance, print prints quotes around strings, whereas cat does not: print(&quot;Hello&quot;) ## [1] &quot;Hello&quot; cat(&quot;Hello&quot;) ## Hello 3.4 Escape Sequences In a string, an escape sequence or escape code consists of a backslash followed by one or more characters. Escape sequences make it possible to: Write quotes or backslashes within a string Write characters that don’t appear on your keyboard (for example, characters in a foreign language) For example, the escape sequence \\n corresponds to the newline character. Notice that the cat function translates \\n into a literal new line, whereas the print function doesn’t: x = &quot;Hello\\nNick&quot; cat(x) ## Hello ## Nick print(x) ## [1] &quot;Hello\\nNick&quot; As another example, suppose we want to put a literal quote in a string. We can either enclose the string in the other kind of quotes, or escape the quotes in the string: x = &#39;She said, &quot;Hi&quot;&#39; cat(x) ## She said, &quot;Hi&quot; y = &quot;She said, \\&quot;Hi\\&quot;&quot; cat(y) ## She said, &quot;Hi&quot; Since escape sequences begin with backslash, we also need to use an escape sequence to write a literal backslash. The escape sequence for a literal backslash is two backslashes: x = &quot;\\\\&quot; cat(x) ## \\ There’s a complete list of escape sequences for R in the ?Quotes help file. Other programming languages also use escape sequences, and many of them are the same as in R. 3.4.1 Raw Strings A raw string is a string where escape sequences are turned off. Raw strings are especially useful for writing regular expressions, which we’ll do later in this lesson. Raw strings begin with r\" and an opening delimiter (, [, or {. Raw strings end with a matching closing delimiter and quote. For example: x = r&quot;(quotes &quot; and backslashes \\)&quot; cat(x) ## quotes &quot; and backslashes \\ Raw strings were added to R in version 4.0 (April 2020), and won’t work correctly in older versions. 3.5 Character Encodings Computers store data as numbers. In order to store text on a computer, we have to agree on a character encoding, a system for mapping characters to numbers. For example, in ASCII, one of the most popular encodings in the United States, the character a maps to the number 97. Many different character encodings exist, and sharing text used to be an inconvenient process of asking or trying to guess the correct encoding. This was so inconvenient that in the 1980s, software engineers around the world united to create the Unicode standard. Unicode includes symbols for nearly all languages in use today, as well as emoji and many ancient languages (such as Egyptian hieroglyphs). Unicode maps characters to numbers, but unlike a character encoding, it doesn’t dictate how those numbers should be mapped to bytes (sequences of ones and zeroes). As a result, there are several different character encodings that support and are synonymous with Unicode. The most popular of these is UTF-8. In R, we can write Unicode characters with the escape sequence \\U followed by the number for the character in base 16. For instance, the number for a in Unicode is 97 (the same as in ASCII). In base 16, 97 is 61. So we can write an a as: x = &quot;\\U61&quot; # or &quot;\\u61&quot; x ## [1] &quot;a&quot; Unicode escape sequences are usually only used for characters that are not easy to type. For example, the cat emoji is number 1f408 (in base 16) in Unicode. So the string \"\\U1f408\" is the cat emoji. Note that being able to see printed Unicode characters also depends on whether the font your computer is using has a glyph (image representation) for that character. Many fonts are limited to a small number of languages. The NerdFont project patches fonts commonly used for programming so that they have better Unicode coverage. Using a font with good Unicode coverage is not essential, but it’s convenient if you expect to work with many different natural languages or love using emoji. 3.5.0.1 Character Encodings in Text Files Most of the time, R will handle character encodings for you automatically. However, if you ever read or write a text file (including CSV and other formats) and the text looks like gibberish, it might be an encoding problem. This is especially true on Windows, the only modern operating system that does not (yet) use UTF-8 as the default encoding. Encoding problems when reading a file can usually be fixed by passing the encoding to the function doing the reading. For instance, the code to read a UTF-8 encoded CSV file on Windows is: read.csv(&quot;my_data.csv&quot;, fileEncoding = &quot;UTF-8&quot;) Other reader functions may use a different parameter to set the encoding, so always check the documentation. On computers where the native language is not set to English, it can also help to set R’s native language to English with Sys.setlocale(locale = \"English\"). Encoding problems when writing a file are slightly more complicated to fix. See this blog post for thorough explanation. 3.6 The stringr Package The rest of this lesson uses stringr, the Tidyverse package for string processing. R also has built-in functions for string processing. The main advantage of stringr is that all of the functions use a common set of parameters, so they’re easier to learn and remember. In practice, data sets often require some cleaning before or during data analysis. One common data cleaning task is editing or extracting parts of strings. stringr has detailed documentation and also a cheatsheet. The first time you use stringr, you’ll have to install it with install.packages (the same as any other package). Then you can load the package with the library function: # install.packages(&quot;stringr&quot;) library(stringr) The typical syntax of a stringr function is: str_NAME(string, pattern, ...) Where: NAME describes what the function does string is the string to search within or transform pattern is the pattern to search for ... is additional, function-specific arguments For example, the str_detect function detects whether the pattern appears within the string: str_detect(&quot;hello&quot;, &quot;el&quot;) ## [1] TRUE str_detect(&quot;hello&quot;, &quot;ol&quot;) ## [1] FALSE Most of the stringr functions are vectorized in the string parameter: str_detect(c(&quot;hello&quot;, &quot;goodbye&quot;, &quot;lo&quot;), &quot;lo&quot;) ## [1] TRUE FALSE TRUE There are a lot of stringr functions. The remainder of this lesson focuses on three that are especially important, as well as some of their variants: str_split_fixed str_replace str_match You can find a complete list of stringr functions with examples in the documentation or cheat sheet. 3.6.1 Splitting Strings The str_split function splits the string at each position that matches the pattern. The characters that match are thrown away. For example, suppose we want to split a sentence into words. Since there’s a space between each word, we can use a space as the pattern: x = &quot;The students in this workshop are great!&quot; result = str_split(x, &quot; &quot;) result ## [[1]] ## [1] &quot;The&quot; &quot;students&quot; &quot;in&quot; &quot;this&quot; &quot;workshop&quot; &quot;are&quot; &quot;great!&quot; The str_split function always returns a list with one element for each input string. Here the list only has one element because x only has one element. We can get the first element with: result[[1]] ## [1] &quot;The&quot; &quot;students&quot; &quot;in&quot; &quot;this&quot; &quot;workshop&quot; &quot;are&quot; &quot;great!&quot; We have to use the double square bracket [[ operator here because x is a list (for a vector, we could use the single square bracket operator instead). Notice that in the printout for result, R gives us a hint that we should use [[ by printing [[1]]. To see why the function returns a list, consider what happens if we try to split two different sentences at once: x = c(x, &quot;Are you listening?&quot;) result = str_split(x, &quot; &quot;) result[[1]] ## [1] &quot;The&quot; &quot;students&quot; &quot;in&quot; &quot;this&quot; &quot;workshop&quot; &quot;are&quot; &quot;great!&quot; result[[2]] ## [1] &quot;Are&quot; &quot;you&quot; &quot;listening?&quot; Each sentence has a different number of words, so the vectors in the result have different lengths. So a list is the only way to store both. The str_split_fixed function is almost the same as str_split, but takes a third argument for the maximum number of splits to make. Because the number of splits is fixed, the function can return the result in a matrix instead of a list. For example: str_split_fixed(x, &quot; &quot;, 3) ## [,1] [,2] [,3] ## [1,] &quot;The&quot; &quot;students&quot; &quot;in this workshop are great!&quot; ## [2,] &quot;Are&quot; &quot;you&quot; &quot;listening?&quot; The str_split_fixed function is often more convenient than str_split because the nth piece of each input string is just the nth column of the result. For example, suppose we want to get the area code from some phone numbers: phones = c(&quot;717-555-3421&quot;, &quot;629-555-8902&quot;, &quot;903-555-6781&quot;) result = str_split_fixed(phones, &quot;-&quot;, 3) result[, 1] ## [1] &quot;717&quot; &quot;629&quot; &quot;903&quot; 3.6.2 Replacing Parts of Strings The str_replace function replaces the pattern the first time it appears in the string. The replacement goes in the third argument. For instance, suppose we want to change the word \"dog\" to \"cat\": x = c(&quot;dogs are great, dogs are fun&quot;, &quot;dogs are fluffy&quot;) str_replace(x, &quot;dog&quot;, &quot;cat&quot;) ## [1] &quot;cats are great, dogs are fun&quot; &quot;cats are fluffy&quot; The str_replace_all function replaces the pattern every time it appears in the string: str_replace_all(x, &quot;dog&quot;, &quot;cat&quot;) ## [1] &quot;cats are great, cats are fun&quot; &quot;cats are fluffy&quot; We can also use the str_replace and str_replace_all functions to delete part of a string by setting the replacement to the empty string \"\". For example, suppose we want to delete the comma: str_replace(x, &quot;,&quot;, &quot;&quot;) ## [1] &quot;dogs are great dogs are fun&quot; &quot;dogs are fluffy&quot; In general, stringr functions with the _all suffix affect all matches. Functions without _all only affect the first match. We’ll learn about str_match at the end of the next section. 3.7 Regular Expressions The stringr functions (including the ones we just learned) use a special language called regular expressions or regex for the pattern. The regular expressions language is also used in many other programming languages besides R. A regular expression can describe a complicated pattern in just a few characters, because some characters, called metacharacters, have special meanings. Letters and numbers are never metacharacters. They’re always literal. Here are a few examples of metacharacters (we’ll look at examples in the subsequent sections): Metacharacter Meaning . any single character (wildcard) \\ escape character (in both R and regex) ^ beginning of string $ end of string [ab] 'a' or 'b' [^ab] any character except 'a' or 'b' ? previous character appears 0 or 1 times * previous character appears 0 or more times + previous character appears 1 or more times () make a group More metacharacters are listed on the stringr cheatsheet, or in ?regex. The str_view function is especially helpful for testing regular expressions. It opens a browser window with the first match in the string highlighted. We’ll use it in the subsequent regex examples. The RegExr website is also helpful for testing regular expressions; it provides an interactive interface where you can write regular expressions and see where they match a string. 3.7.1 The Wildcard The regex wildcard character is . and matches any single character. For example: x = &quot;dog&quot; str_view(x, &quot;d.g&quot;) By default, regex searches from left to right: str_view(x, &quot;.&quot;) 3.7.2 Escape Sequences Like R, regular expressions can contain escape sequences that begin with a backslash. These are computed separately and after R escape sequences. The main use for escape sequences in regex is to turn a metacharacter into a literal character. For example, suppose we want to match a literal dot .. The regex for a literal dot is \\.. Since backslashes in R strings have to be escaped, the R string for this regex is \"\\\\.. Then the regex works: str_view(&quot;this.string&quot;, &quot;\\\\.&quot;) The double backslash can be confusing, and it gets worse if we want to match a literal backslash. We have to escape the backslash in the regex (because backslash is the regex escape character) and then also have to escape the backslashes in R (because backslash is also the R escape character). So to match a single literal backslash in R, the code is: str_view(&quot;this\\\\that&quot;, &quot;\\\\\\\\&quot;) Raw strings are helpful here, because they make the backslash literal in R strings (but still not in regex). We can use raw strings to write the above as: str_view(r&quot;(this\\that)&quot;, r&quot;(\\\\)&quot;) You can turn off regular expressions entirely in stringr with the fixed function: str_view(x, fixed(&quot;.&quot;)) It’s good to turn off regular expressions whenever you don’t need them, both to avoid mistakes and because they take longer to compute. 3.7.3 Anchors By default, a regex will match anywhere in the string. If you want to force a match at specific place, use an anchor. The beginning of string anchor is ^. It marks the beginning of the string, but doesn’t count as a character in the match. For example, suppose we want to match an a at the beginning of the string: x = c(&quot;abc&quot;, &quot;cab&quot;) str_view(x, &quot;a&quot;) str_view(x, &quot;^a&quot;) It doesn’t make sense to put characters before ^, since no characters can come before the beginning of the string. Likewise, the end of string anchor is $. It marks the end of the string, but doesn’t count as a character in the match. 3.7.4 Character Classes In regex, square brackets [ ] create a character class. A character class counts as one character, but that character can be any of the characters inside the square brackets. The square brackets themselves don’t count as characters in the match. For example, suppose we want to match a c followed by either a or t: x = c(&quot;ca&quot;, &quot;ct&quot;, &quot;cat&quot;, &quot;cta&quot;) str_view(x, &quot;c[ta]&quot;) You can use a dash - in a character class to create a range. For example, to match letters p through z: str_view(x, &quot;c[p-z]&quot;) Ranges also work with numbers and capital letters. To match a literal dash, place the dash at the end of the character class (instead of between two other characters), as in [abc-]. Most metacharacters are literal when inside a character class. For example, [.] matches a literal dot. A hat ^ at the beginning of the character class negates the class. So for example, [^abc] matches any one character except for a, b, or c: str_view(&quot;abcdef&quot;, &quot;[^abc]&quot;) 3.7.5 Quantifiers Quantifiers are metacharacters that affect how many times the preceeding character must appear in a match. The quantifier itself doesn’t count as a character in the match. For example, the ? quantifier means the preceeding character can appear 0 or 1 times. In other words, ? makes the preceeding character optional. For example: x = c(&quot;abc&quot;, &quot;ab&quot;, &quot;ac&quot;, &quot;abbc&quot;) str_view(x, &quot;ab?c&quot;) The * quantifier means the preceeding character can appear 0 or more times. In other words, * means the preceeding character can appear any number of times or not at all. str_view(x, &quot;ab*c&quot;) The + quantifier means the preceeding character must appear 1 or more times. Quantifiers are greedy, meaning they always match as many characters as possible. 3.7.6 Groups In regex, parentheses create a group. Groups can be affected by quantifiers, making it possible to repeat a pattern (rather than just a character). The parentheses themselves don’t count as characters in the match. For example: x = c(&quot;cats, dogs, and frogs&quot;, &quot;cats and frogs&quot;) str_view(x, &quot;cats(, dogs,)? and frogs&quot;) 3.7.7 Extracting Matches Groups are espcially useful with the stringr functions str_match and str_match_all. The str_match function extracts the overall match to the pattern, as well as the match to each group. So you can use str_match to split a string in more complicated ways than str_split, or to extract specifc pieces of a string. For example, suppose we want to split an email address: str_match(&quot;naulle@ucdavis.edu&quot;, &quot;([^@]+)@(.+)[.](.+)&quot;) ## [,1] [,2] [,3] [,4] ## [1,] &quot;naulle@ucdavis.edu&quot; &quot;naulle&quot; &quot;ucdavis&quot; &quot;edu&quot; 3.7.8 Case Study: Extracting Emails "],["automating-tasks.html", "4 Automating Tasks 4.1 Loops 4.2 Planning for Iteration", " 4 Automating Tasks 4.1 Loops One major benefit of using a programming language like R is that repetitive tasks can be automated. We’ve already seen two ways to do this: Vectorization, introduced in Section ?? Apply functions, introduced in Section ?? Both of these are iteration strategies. They iterate over some object, and compute something for each element. Each one of these computations is one iteration. Vectorization is the most efficient iteration strategy, but only works with vectorized functions and vectors. Apply functions are more flexible—they work with any function and any data structure with elements—but less efficient and less concise. A loop is another iteration strategy, one that’s even more flexible than apply functions. Besides being flexible, loops are a feature of almost all modern programming languages, so it’s useful to understand them. In R, there are two kinds of loops. We’ll learn both. 4.1.1 For-loops A for-loop runs a block of code once for each element of a vector or list. The for keyword creates a for-loop. Here’s the syntax: for (I in DATA) { # Your code goes here } The variable I is called the induction variable. At the beginning of each iteration, I is assigned the next element of the vector or list DATA. The loop iterates once for each element of DATA, unless you use a keyword to exit the loop early (more about this in Section 4.1.4). As with if-statements and functions, the curly braces { } are only required if the body contains multiple lines of code. Unlike the other iteration strategies, loops do not automatically return a result. You have complete control over the output, which means that anything you want to save must be assigned to a variable. For example, let’s make a loop that repeatedly adds a number to a running total and squares the new total. We’ll use a variable total to keep track of the running total as the loop iterates: numbers = c(-1, 1, -3, 2) total = 0 for (number in numbers) { total = (total + number)^2 } total ## [1] 9 Use for-loops when some or all of the iterations depend on results from other iterations. If the iterations are not dependent, use one of: Vectorization (because it’s faster) Apply functions (because they’re idiomatic) In some cases, you can use vectorization even when the iterations are dependent. For example, you can use vectorization to compute the sum of the cubes of several numbers: sum(numbers^3) ## [1] -19 4.1.2 While-loops A while-loop runs a block of code repeatedly as long as some condition is TRUE. The while keyword creates a while-loop. Here’s the syntax: while (CONDITION) { # Your code goes here } The CONDITION should be a scalar logical value or an expression that returns one. At the beginning of each iteration, CONDITION is checked, and the loop exits if it is FALSE. As always, the curly braces { } are only required if the body contains multiple lines of code. For example, suppose you want to add up numbers from 0 to 50, but stop as soon as the total is greater than 50: num50 = seq(0, 50) total = 0 i = 1 while (total &lt; 50) { total = total + num50[i] message(&quot;i is &quot;, i, &quot; total is &quot;, total) i = i + 1 } ## i is 1 total is 0 ## i is 2 total is 1 ## i is 3 total is 3 ## i is 4 total is 6 ## i is 5 total is 10 ## i is 6 total is 15 ## i is 7 total is 21 ## i is 8 total is 28 ## i is 9 total is 36 ## i is 10 total is 45 ## i is 11 total is 55 total ## [1] 55 i ## [1] 12 While-loops are a generalization of for-loops. They tend to be most useful when you don’t know how many iterations will be necessary. For example, suppose you want to repeat a computation until the result falls within some range of values. 4.1.3 Saving Multiple Results Loops often produce a different result for each iteration. If you want to save more than one result, there are a few things you must do. First, set up an index vector. The index vector should usually be congruent to the number of iterations or the input. The seq_along function returns a congruent index vector when passed a vector or list. For instance, let’s make in index for the numbers vector from Section 4.1.1: index = seq_along(numbers) The loop will iterate over the index rather than the input, so the induction variable will track the current iteration number. On the first iteration, the induction variable will be 1, on the second it will be 2, and so on. Then you can use the induction variable and indexing to get the input for each iteration. Second, set up an empty output vector or list. This should usually be congruent to the input, or one element longer (the extra element comes from the initial value). R has several functions for creating vectors. We’ve already seen a few, but here are more: logical, integer, numeric, complex, and character to create an empty vector with a specific type and length vector to create an empty vector with a specific type and length rep to create a vector by repeating elements of some other vector Empty vectors are filled with FALSE, 0, or \"\", depending on the type of the vector. Here are some examples: logical(3) ## [1] FALSE FALSE FALSE numeric(4) ## [1] 0 0 0 0 rep(c(1, 2), 2) ## [1] 1 2 1 2 Let’s create an empty numeric vector congruent to numbers: n = length(numbers) result = numeric(n) As with the input, you can use the induction variable and indexing to set the output for each iteration. Creating a vector or list in advance to store something, as we’ve just done, is called preallocation. Preallocation is extremely important for efficiency in loops. Avoid the temptation to use c or append to build up the output bit by bit in each iteration. Finally, write the loop, making sure to get the input and set the output. Here’s the loop for the squared sums example: for (i in index) { prev = if (i &gt; 1) result[i - 1] else 0 result[i] = (numbers[i] + prev)^2 } result ## [1] 1 4 1 9 4.1.4 Break &amp; Next The break keyword causes a loop to immediately exit. It only makes sense to use break inside of an if-statement. For example, suppose we want to print each string in a vector, but stop at the first missing value. We can do this with break: my_messages = c(&quot;Hi&quot;, &quot;Hello&quot;, NA, &quot;Goodbye&quot;) for (msg in my_messages) { if (is.na(msg)) break message(msg) } ## Hi ## Hello The next keyword causes a loop to immediately go to the next iteration. As with break, it only makes sense to use next inside of an if-statement. Let’s modify the previous example so that missing values are skipped, but don’t cause printing to stop. Here’s the code: for (msg in my_messages) { if (is.na(msg)) next message(msg) } ## Hi ## Hello ## Goodbye These keywords work with both for-loops and while-loops. 4.1.5 Example: The Collatz Conjecture The Collatz Conjecture is a conjecture in math that was introduced in 1937 by Lothar Collatz and remains unproven today, despite being relatively easy to explain. Here’s a statement of the conjecture: Start from any positive integer. If the integer is even, divide by 2. If the integer is odd, multiply by 3 and add 1. If the result is not 1, repeat using the result as the new starting value. The result will always reach 1 eventually, regardless of the starting value. The sequences of numbers this process generates are called Collatz sequences. For instance, the Collatz sequence starting from 2 is 2, 1. The Collatz sequence starting from 12 is 12, 6, 3, 10, 5, 16, 8, 4, 2, 1. As a final loop example, let’s use a while-loop to compute Collatz sequences. Here’s the code: n = 5 i = 0 while (n != 1) { i = i + 1 if (n %% 2 == 0) { n = n / 2 } else { n = 3 * n + 1 } message(paste0(n, &quot; &quot;)) } ## 16 ## 8 ## 4 ## 2 ## 1 As of 2020, scientists have used computers to check the Collatz sequences for every number up to approximately \\(2^{64}\\). For more details about the Collatz Conjecture, check out this video. 4.2 Planning for Iteration At first it may seem difficult to decide if and what kind of iteration to use. Start by thinking about whether you need to do something over and over. If you don’t, then you probably don’t need to use iteration. If you do, then try iteration strategies in this order: vectorization apply functions Try an apply function if iterations are independent. for/while-loops Try a for-loop if some iterations depend on others. Try a while-loop if the number of iterations is unknown. recursion (which isn’t covered here) Convenient for naturally recursive problems (like Fibonacci), but often there are faster solutions. Start by writing the code for just one iteration. Make sure that code works; it’s easy to test code for one iteration. When you have one iteration working, then try using the code with an iteration strategy (you will have to make some small changes). If it doesn’t work, try to figure out which iteration is causing the problem. One way to do this is to use message to print out information. Then try to write the code for the broken iteration, get that iteration working, and repeat this whole process. "],["references.html", "References", " References This reader would not have been possible without the many excellent reference texts created by other members of the R community. Now that you’ve completed this reader, these texts are a great way to continue you R learning journey. Advanced R by Hadley Wickham is a must-read if you want a deep understanding of R. It provides many examples of R features that are important for package/software development. Other texts I’ve found useful include: What They Forgot to Teach You About R by Bryan &amp; Hester. The Art of R Programming by Matloff (of UC Davis). A general reference on R programming, with more of a computer science and software engineering perspective than most R texts. The R Inferno by Burns. A discussion of the most difficult and confusing parts of R. R Packages by Wickham. A gentle, modern introduction to creating packages for R. Writing R Extensions by the R core developers. A description of how to create packages and other extensions for R. R Language Definition by the R core developers. Documentation about how R works at a low level. R Internals by the R core developers. Documentation about how R works internally (that is, its C code). Finally, here are a few other readers and notes created by DataLab staff: My personal teaching notes from several years of teaching statistical computing. R Basics, our workshop series aimed at people just starting to learn R. Adventures in Data Science, our course introducing humanities undergraduates to data science techniques. Python Basics, our workshop series aimed at people just starting to learn Python. Intermediate Python, this reader’s counterpart for Python users. "],["assessment.html", "Assessment", " Assessment If you are taking this workshop to complete a GradPathways Pathway, you can download the assessment instructions here. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
