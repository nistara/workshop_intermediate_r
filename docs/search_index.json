[["index.html", "Intermediate R Overview", " Intermediate R Nick Ulle 2022-12-16 Overview This 5-part workshop series (in which the 5th workshop is an optional online Q&amp;A) aims to help learners understand the relatively small but fundamental computational model underlying the R language. This will help you reason about code before you write and run it, and to debug it if it doesn’t do what you want. A sound understanding of this computational model makes programming in R much easier and more productive! After this workshop series learners should be able to: Define “REPL” Interpret error messages Navigate the global environment Explain data type hierarchy Evaluate the consequences of implicit coercion Describe how function calls work Define scoping rules Distinguish between S3 and S4 Write a function Plan an approach for debugging code Increase your productivity and confidence in using R Identify where to go to learn more! Another title for this workshop could be “Everything You Should Have Learned About R.” These workshops are not an introduction to R. Participants are expected to have prior experience using R, be comfortable with basic R syntax, and to have it pre-installed and running on their laptops. This series is appropriate for motivated intermediate to advanced users who want a better understanding of base R. "],["language-fundamentals.html", "1 Language Fundamentals 1.1 Variable Scope &amp; Lookup", " 1 Language Fundamentals 1.1 Variable Scope &amp; Lookup 1.1.1 Local Variables A variable’s scope is the section of code where it exists and is accessible. The exists function checks whether a variable is in scope: exists(&quot;zz&quot;) ## [1] FALSE zz = 3 exists(&quot;zz&quot;) ## [1] TRUE When you create a function, you create a new scope. Variables defined inside of a function are local to the function. Local variables cannot be accessed from outside: rescale = function(x, center, scale) { centered = x - center centered / scale } centered ## Error in eval(expr, envir, enclos): object &#39;centered&#39; not found exists(&quot;centered&quot;) ## [1] FALSE Local variables are reset each time the function is called: f = function() { is_z_in_scope = exists(&quot;z&quot;) z = 42 is_z_in_scope } f() ## [1] FALSE f() ## [1] FALSE 1.1.2 Lexical Scoping A function can use variables defined outside (non-local), but only if those variables are in scope where the function was defined. This property is called lexical scoping. Let’s see how this works in practice. First, we’ll define a variable cats and then define a function get_cats in the same place (the top level, not inside any functions). As a result, the cats variable is in scope inside of the get_cats function: cats = 3 get_cats = function() cats get_cats() ## [1] 3 Now let’s define a variable dogs inside of a function create_dogs. We’ll also define a function get_dogs at the top level. The variable dogs is not in scope at the top level, so it’s not in scope inside of the get_dogs function: create_dogs = function() { dogs = &quot;hello&quot; } get_dogs = function() dogs create_dogs() get_dogs() ## Error in get_dogs(): object &#39;dogs&#39; not found Variables defined directly in the R console are global and available to any function. Local variables mask (hide) non-local variables with the same name: get_parrot = function() { parrot = 3 parrot } parrot = 42 get_parrot() ## [1] 3 There’s one exception to this rule. We often use variables that refer to functions in calls: #mean() In this case, the variable must refer to a function, so R ignores local variables that aren’t functions. For example: my_mean = function() { mean = 0 mean(c(1, 2, 3)) } my_mean() ## [1] 2 my_get_cats = function() { get_cats = 10 get_cats() } my_get_cats() ## [1] 3 1.1.3 Dynamic Lookup Variable lookup happens when a function is called, not when it’s defined. This is called dynamic lookup. For example, the result from get_cats, which accesses the global variable cats, changes if we change the value of cats: cats = 10 get_cats() ## [1] 10 cats = 20 get_cats() ## [1] 20 1.1.4 Summary This section covered a lot of details about R’s rules for variable scope and lookup. Here are the key takeaways: Function definitions (or local()) create a new scope. Local variables Are private Get reset for each call Mask non-local variables (exception: function calls) Lexical scoping: where a function is defined determines which non-local variables are in scope. Dynamic lookup: when a function is called determines values of non-local variables. "],["debugging.html", "2 Debugging", " 2 Debugging "],["string-date-processing.html", "3 String &amp; Date Processing 3.1 The Tidyverse 3.2 Date Processing 3.3 Printing Output 3.4 Escape Sequences 3.5 Character Encodings 3.6 The stringr Package 3.7 Regular Expressions", " 3 String &amp; Date Processing 3.1 The Tidyverse The Tidyverse is a popular collection of packages for doing data science in R. The packages are made by many of the same people that make RStudio. They provide alternatives to R’s built-in tools for: Manipulating strings (package stringr) Making visualizations (package ggplot2) Reading files (package readr) Manipulating data frames (packages dplyr, tidyr, tibble) And more Think of the Tidyverse as a different dialect of R. Sometimes the syntax is different, and sometimes ideas are easier or harder to express concisely. Whether to use base R or the Tidyverse is mostly subjective. As a result, the Tidyverse is somewhat polarizing in the R community. It’s useful to be literate in both, since both are popular. One advantage of the Tidyverse is that the packages are usually well-documented. For example, there are documentation websites and cheat sheets for most Tidyverse packages. 3.2 Date Processing Besides strings, dates and times are another kind of data that require special attention to prepare for analysis. This is especially important if you want to do anything that involves sorting dates, like making a line plot with dates on one axis. Dates may not be sorted correctly if they haven’t been converted to one of R’s date classes. There several built-in functions and also many packages for date processing. As with visualization and string processing, the Tidyverse packages have the best combination of simple design and clear documentation. There are three Tidyverse packages for processing dates and times: lubridate, the primary package for working with dates and times hms, a package specifically for working with times clock, a new package for working with dates and times We’ll focus on the lubridate package. As always, you’ll have to install the package if you haven’t already, and then load it: # install.packages(&quot;lubridate&quot;) library(&quot;lubridate&quot;) ## ## Attaching package: &#39;lubridate&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## date, intersect, setdiff, union The most common task is to convert a string into a date or time class. For instance, when you load a data set, you might have dates that look like this: dates = c(&quot;Jan 10, 2021&quot;, &quot;Sep 3, 2018&quot;, &quot;Feb 28, 1982&quot;) dates ## [1] &quot;Jan 10, 2021&quot; &quot;Sep 3, 2018&quot; &quot;Feb 28, 1982&quot; These are strings, so it’s relatively difficult to sort the dates, do arithmetic on them, or extract just one part (such as the year). There are several lubridate functions to automatically convert strings into dates. They are named with one letter for each part of the date. For instance, the dates in the example have the month (m), then the day (d), and then the year (y), so we can use the mdy function: result = mdy(dates) result ## [1] &quot;2021-01-10&quot; &quot;2018-09-03&quot; &quot;1982-02-28&quot; class(result) ## [1] &quot;Date&quot; Notice that the dates now have class Date, one of R’s built-in classes for representing dates, and that they print differently. You can find a full list of the automatic string to date conversion functions in the lubridate documentation. Occasionally, a date string may have a format that lubridate can’t convert automatically. In that case, you can use the fast_strptime function to describe the format in detail. At a minimum, the function requires two arguments: the vector of strings to convert and a format string. The format string describes the format of the dates, and is based on the syntax of strptime, a function provided by many programming languages for converting strings to dates (including R). In a format string, a percent sign % followed by a character is called a specification and has a special meaning. Here are a few of the most useful ones: Specification Description January 29, 2015 %Y 4-digit year 2015 %y 2-digit year 15 %m 2-digit month 01 %B full month name January %b short month name Jan %d day of month 29 %% literal % % You can find a complete list in ?fast_strptime. Other characters in the format string do not have any special meaning. Write the format string so that it matches the format of the dates you want to convert. For example, let’s try converting an unusual time format: odd_time = &quot;6 minutes, 32 seconds after 10 o&#39;clock&quot; fast_strptime(odd_time, &quot;%M minutes, %S seconds after %H o&#39;clock&quot;) ## [1] &quot;0-01-01 10:06:32 UTC&quot; R usually represents dates with the class Date, and date-times with the classes POSIXct and POSIXlt. The difference between the two date-time classes is somewhat technical, but you can read more about it in ?POSIXlt. There is no built-in class to represent times alone, which is why the result in the example above includes a date. Nonetheless, the hms package provides the hms class to represent times without dates. Once you’ve converted a string to a date, the lubridate package provides a variety of functions to get or set the parts individually. Here are a few examples: day(result) ## [1] 10 3 28 month(result) ## [1] 1 9 2 You can find a complete list in the lubridate documentation. 3.2.1 Case Study: Correcting Dates 3.3 Printing Output The cat function prints a string in the R console. If you pass multiple arguments, they will be concatenated: cat(&quot;Hello&quot;) ## Hello cat(&quot;Hello&quot;, &quot;Nick&quot;) ## Hello Nick Pitfall 1: Printing a string is different from returning a string. The cat function only prints (and always returns NULL). For example: f = function() { cat(&quot;Hello&quot;) } x = f() ## Hello x ## NULL If you just want to concatenate some strings (but not necessarily print them), use paste instead of cat. The paste function returns a string. The str_c function in stringr (a package we’ll learn about later in this lesson) can also concatenate strings. Pitfall 2: Remember to print strings with the cat function, not the print function. The print function prints R’s representation of an object, the same as if you had entered the object in the console without calling print. For instance, print prints quotes around strings, whereas cat does not: print(&quot;Hello&quot;) ## [1] &quot;Hello&quot; cat(&quot;Hello&quot;) ## Hello 3.4 Escape Sequences In a string, an escape sequence or escape code consists of a backslash followed by one or more characters. Escape sequences make it possible to: Write quotes or backslashes within a string Write characters that don’t appear on your keyboard (for example, characters in a foreign language) For example, the escape sequence \\n corresponds to the newline character. Notice that the cat function translates \\n into a literal new line, whereas the print function doesn’t: x = &quot;Hello\\nNick&quot; cat(x) ## Hello ## Nick print(x) ## [1] &quot;Hello\\nNick&quot; As another example, suppose we want to put a literal quote in a string. We can either enclose the string in the other kind of quotes, or escape the quotes in the string: x = &#39;She said, &quot;Hi&quot;&#39; cat(x) ## She said, &quot;Hi&quot; y = &quot;She said, \\&quot;Hi\\&quot;&quot; cat(y) ## She said, &quot;Hi&quot; Since escape sequences begin with backslash, we also need to use an escape sequence to write a literal backslash. The escape sequence for a literal backslash is two backslashes: x = &quot;\\\\&quot; cat(x) ## \\ There’s a complete list of escape sequences for R in the ?Quotes help file. Other programming languages also use escape sequences, and many of them are the same as in R. 3.4.1 Raw Strings A raw string is a string where escape sequences are turned off. Raw strings are especially useful for writing regular expressions, which we’ll do later in this lesson. Raw strings begin with r\" and an opening delimiter (, [, or {. Raw strings end with a matching closing delimiter and quote. For example: x = r&quot;(quotes &quot; and backslashes \\)&quot; cat(x) ## quotes &quot; and backslashes \\ Raw strings were added to R in version 4.0 (April 2020), and won’t work correctly in older versions. 3.5 Character Encodings Computers store data as numbers. In order to store text on a computer, we have to agree on a character encoding, a system for mapping characters to numbers. For example, in ASCII, one of the most popular encodings in the United States, the character a maps to the number 97. Many different character encodings exist, and sharing text used to be an inconvenient process of asking or trying to guess the correct encoding. This was so inconvenient that in the 1980s, software engineers around the world united to create the Unicode standard. Unicode includes symbols for nearly all languages in use today, as well as emoji and many ancient languages (such as Egyptian hieroglyphs). Unicode maps characters to numbers, but unlike a character encoding, it doesn’t dictate how those numbers should be mapped to bytes (sequences of ones and zeroes). As a result, there are several different character encodings that support and are synonymous with Unicode. The most popular of these is UTF-8. In R, we can write Unicode characters with the escape sequence \\U followed by the number for the character in base 16. For instance, the number for a in Unicode is 97 (the same as in ASCII). In base 16, 97 is 61. So we can write an a as: x = &quot;\\U61&quot; # or &quot;\\u61&quot; x ## [1] &quot;a&quot; Unicode escape sequences are usually only used for characters that are not easy to type. For example, the cat emoji is number 1f408 (in base 16) in Unicode. So the string \"\\U1f408\" is the cat emoji. Note that being able to see printed Unicode characters also depends on whether the font your computer is using has a glyph (image representation) for that character. Many fonts are limited to a small number of languages. The NerdFont project patches fonts commonly used for programming so that they have better Unicode coverage. Using a font with good Unicode coverage is not essential, but it’s convenient if you expect to work with many different natural languages or love using emoji. 3.5.0.1 Character Encodings in Text Files Most of the time, R will handle character encodings for you automatically. However, if you ever read or write a text file (including CSV and other formats) and the text looks like gibberish, it might be an encoding problem. This is especially true on Windows, the only modern operating system that does not (yet) use UTF-8 as the default encoding. Encoding problems when reading a file can usually be fixed by passing the encoding to the function doing the reading. For instance, the code to read a UTF-8 encoded CSV file on Windows is: read.csv(&quot;my_data.csv&quot;, fileEncoding = &quot;UTF-8&quot;) Other reader functions may use a different parameter to set the encoding, so always check the documentation. On computers where the native language is not set to English, it can also help to set R’s native language to English with Sys.setlocale(locale = \"English\"). Encoding problems when writing a file are slightly more complicated to fix. See this blog post for thorough explanation. 3.6 The stringr Package The rest of this lesson uses stringr, the Tidyverse package for string processing. R also has built-in functions for string processing. The main advantage of stringr is that all of the functions use a common set of parameters, so they’re easier to learn and remember. In practice, data sets often require some cleaning before or during data analysis. One common data cleaning task is editing or extracting parts of strings. stringr has detailed documentation and also a cheatsheet. The first time you use stringr, you’ll have to install it with install.packages (the same as any other package). Then you can load the package with the library function: # install.packages(&quot;stringr&quot;) library(stringr) The typical syntax of a stringr function is: str_NAME(string, pattern, ...) Where: NAME describes what the function does string is the string to search within or transform pattern is the pattern to search for ... is additional, function-specific arguments For example, the str_detect function detects whether the pattern appears within the string: str_detect(&quot;hello&quot;, &quot;el&quot;) ## [1] TRUE str_detect(&quot;hello&quot;, &quot;ol&quot;) ## [1] FALSE Most of the stringr functions are vectorized in the string parameter: str_detect(c(&quot;hello&quot;, &quot;goodbye&quot;, &quot;lo&quot;), &quot;lo&quot;) ## [1] TRUE FALSE TRUE There are a lot of stringr functions. The remainder of this lesson focuses on three that are especially important, as well as some of their variants: str_split_fixed str_replace str_match You can find a complete list of stringr functions with examples in the documentation or cheat sheet. 3.6.1 Splitting Strings The str_split function splits the string at each position that matches the pattern. The characters that match are thrown away. For example, suppose we want to split a sentence into words. Since there’s a space between each word, we can use a space as the pattern: x = &quot;The students in this workshop are great!&quot; result = str_split(x, &quot; &quot;) result ## [[1]] ## [1] &quot;The&quot; &quot;students&quot; &quot;in&quot; &quot;this&quot; &quot;workshop&quot; &quot;are&quot; &quot;great!&quot; The str_split function always returns a list with one element for each input string. Here the list only has one element because x only has one element. We can get the first element with: result[[1]] ## [1] &quot;The&quot; &quot;students&quot; &quot;in&quot; &quot;this&quot; &quot;workshop&quot; &quot;are&quot; &quot;great!&quot; We have to use the double square bracket [[ operator here because x is a list (for a vector, we could use the single square bracket operator instead). Notice that in the printout for result, R gives us a hint that we should use [[ by printing [[1]]. To see why the function returns a list, consider what happens if we try to split two different sentences at once: x = c(x, &quot;Are you listening?&quot;) result = str_split(x, &quot; &quot;) result[[1]] ## [1] &quot;The&quot; &quot;students&quot; &quot;in&quot; &quot;this&quot; &quot;workshop&quot; &quot;are&quot; &quot;great!&quot; result[[2]] ## [1] &quot;Are&quot; &quot;you&quot; &quot;listening?&quot; Each sentence has a different number of words, so the vectors in the result have different lengths. So a list is the only way to store both. The str_split_fixed function is almost the same as str_split, but takes a third argument for the maximum number of splits to make. Because the number of splits is fixed, the function can return the result in a matrix instead of a list. For example: str_split_fixed(x, &quot; &quot;, 3) ## [,1] [,2] [,3] ## [1,] &quot;The&quot; &quot;students&quot; &quot;in this workshop are great!&quot; ## [2,] &quot;Are&quot; &quot;you&quot; &quot;listening?&quot; The str_split_fixed function is often more convenient than str_split because the nth piece of each input string is just the nth column of the result. For example, suppose we want to get the area code from some phone numbers: phones = c(&quot;717-555-3421&quot;, &quot;629-555-8902&quot;, &quot;903-555-6781&quot;) result = str_split_fixed(phones, &quot;-&quot;, 3) result[, 1] ## [1] &quot;717&quot; &quot;629&quot; &quot;903&quot; 3.6.2 Replacing Parts of Strings The str_replace function replaces the pattern the first time it appears in the string. The replacement goes in the third argument. For instance, suppose we want to change the word \"dog\" to \"cat\": x = c(&quot;dogs are great, dogs are fun&quot;, &quot;dogs are fluffy&quot;) str_replace(x, &quot;dog&quot;, &quot;cat&quot;) ## [1] &quot;cats are great, dogs are fun&quot; &quot;cats are fluffy&quot; The str_replace_all function replaces the pattern every time it appears in the string: str_replace_all(x, &quot;dog&quot;, &quot;cat&quot;) ## [1] &quot;cats are great, cats are fun&quot; &quot;cats are fluffy&quot; We can also use the str_replace and str_replace_all functions to delete part of a string by setting the replacement to the empty string \"\". For example, suppose we want to delete the comma: str_replace(x, &quot;,&quot;, &quot;&quot;) ## [1] &quot;dogs are great dogs are fun&quot; &quot;dogs are fluffy&quot; In general, stringr functions with the _all suffix affect all matches. Functions without _all only affect the first match. We’ll learn about str_match at the end of the next section. 3.7 Regular Expressions The stringr functions (including the ones we just learned) use a special language called regular expressions or regex for the pattern. The regular expressions language is also used in many other programming languages besides R. A regular expression can describe a complicated pattern in just a few characters, because some characters, called metacharacters, have special meanings. Letters and numbers are never metacharacters. They’re always literal. Here are a few examples of metacharacters (we’ll look at examples in the subsequent sections): Metacharacter Meaning . any single character (wildcard) \\ escape character (in both R and regex) ^ beginning of string $ end of string [ab] 'a' or 'b' [^ab] any character except 'a' or 'b' ? previous character appears 0 or 1 times * previous character appears 0 or more times + previous character appears 1 or more times () make a group More metacharacters are listed on the stringr cheatsheet, or in ?regex. The str_view function is especially helpful for testing regular expressions. It opens a browser window with the first match in the string highlighted. We’ll use it in the subsequent regex examples. The RegExr website is also helpful for testing regular expressions; it provides an interactive interface where you can write regular expressions and see where they match a string. 3.7.1 The Wildcard The regex wildcard character is . and matches any single character. For example: x = &quot;dog&quot; str_view(x, &quot;d.g&quot;) By default, regex searches from left to right: str_view(x, &quot;.&quot;) 3.7.2 Escape Sequences Like R, regular expressions can contain escape sequences that begin with a backslash. These are computed separately and after R escape sequences. The main use for escape sequences in regex is to turn a metacharacter into a literal character. For example, suppose we want to match a literal dot .. The regex for a literal dot is \\.. Since backslashes in R strings have to be escaped, the R string for this regex is \"\\\\.. Then the regex works: str_view(&quot;this.string&quot;, &quot;\\\\.&quot;) The double backslash can be confusing, and it gets worse if we want to match a literal backslash. We have to escape the backslash in the regex (because backslash is the regex escape character) and then also have to escape the backslashes in R (because backslash is also the R escape character). So to match a single literal backslash in R, the code is: str_view(&quot;this\\\\that&quot;, &quot;\\\\\\\\&quot;) Raw strings are helpful here, because they make the backslash literal in R strings (but still not in regex). We can use raw strings to write the above as: str_view(r&quot;(this\\that)&quot;, r&quot;(\\\\)&quot;) You can turn off regular expressions entirely in stringr with the fixed function: str_view(x, fixed(&quot;.&quot;)) It’s good to turn off regular expressions whenever you don’t need them, both to avoid mistakes and because they take longer to compute. 3.7.3 Anchors By default, a regex will match anywhere in the string. If you want to force a match at specific place, use an anchor. The beginning of string anchor is ^. It marks the beginning of the string, but doesn’t count as a character in the match. For example, suppose we want to match an a at the beginning of the string: x = c(&quot;abc&quot;, &quot;cab&quot;) str_view(x, &quot;a&quot;) str_view(x, &quot;^a&quot;) It doesn’t make sense to put characters before ^, since no characters can come before the beginning of the string. Likewise, the end of string anchor is $. It marks the end of the string, but doesn’t count as a character in the match. 3.7.4 Character Classes In regex, square brackets [ ] create a character class. A character class counts as one character, but that character can be any of the characters inside the square brackets. The square brackets themselves don’t count as characters in the match. For example, suppose we want to match a c followed by either a or t: x = c(&quot;ca&quot;, &quot;ct&quot;, &quot;cat&quot;, &quot;cta&quot;) str_view(x, &quot;c[ta]&quot;) You can use a dash - in a character class to create a range. For example, to match letters p through z: str_view(x, &quot;c[p-z]&quot;) Ranges also work with numbers and capital letters. To match a literal dash, place the dash at the end of the character class (instead of between two other characters), as in [abc-]. Most metacharacters are literal when inside a character class. For example, [.] matches a literal dot. A hat ^ at the beginning of the character class negates the class. So for example, [^abc] matches any one character except for a, b, or c: str_view(&quot;abcdef&quot;, &quot;[^abc]&quot;) 3.7.5 Quantifiers Quantifiers are metacharacters that affect how many times the preceeding character must appear in a match. The quantifier itself doesn’t count as a character in the match. For example, the ? quantifier means the preceeding character can appear 0 or 1 times. In other words, ? makes the preceeding character optional. For example: x = c(&quot;abc&quot;, &quot;ab&quot;, &quot;ac&quot;, &quot;abbc&quot;) str_view(x, &quot;ab?c&quot;) The * quantifier means the preceeding character can appear 0 or more times. In other words, * means the preceeding character can appear any number of times or not at all. str_view(x, &quot;ab*c&quot;) The + quantifier means the preceeding character must appear 1 or more times. Quantifiers are greedy, meaning they always match as many characters as possible. 3.7.6 Groups In regex, parentheses create a group. Groups can be affected by quantifiers, making it possible to repeat a pattern (rather than just a character). The parentheses themselves don’t count as characters in the match. For example: x = c(&quot;cats, dogs, and frogs&quot;, &quot;cats and frogs&quot;) str_view(x, &quot;cats(, dogs,)? and frogs&quot;) 3.7.7 Extracting Matches Groups are espcially useful with the stringr functions str_match and str_match_all. The str_match function extracts the overall match to the pattern, as well as the match to each group. So you can use str_match to split a string in more complicated ways than str_split, or to extract specifc pieces of a string. For example, suppose we want to split an email address: str_match(&quot;naulle@ucdavis.edu&quot;, &quot;([^@]+)@(.+)[.](.+)&quot;) ## [,1] [,2] [,3] [,4] ## [1,] &quot;naulle@ucdavis.edu&quot; &quot;naulle&quot; &quot;ucdavis&quot; &quot;edu&quot; 3.7.8 Case Study: Extracting Emails "],["automating-tasks.html", "4 Automating Tasks 4.1 Loops 4.2 Planning for Iteration", " 4 Automating Tasks 4.1 Loops One major benefit of using a programming language like R is that repetitive tasks can be automated. We’ve already seen two ways to do this: Vectorization, introduced in Section ?? Apply functions, introduced in Section ?? Both of these are iteration strategies. They iterate over some object, and compute something for each element. Each one of these computations is one iteration. Vectorization is the most efficient iteration strategy, but only works with vectorized functions and vectors. Apply functions are more flexible—they work with any function and any data structure with elements—but less efficient and less concise. A loop is another iteration strategy, one that’s even more flexible than apply functions. Besides being flexible, loops are a feature of almost all modern programming languages, so it’s useful to understand them. In R, there are two kinds of loops. We’ll learn both. 4.1.1 For-loops A for-loop runs a block of code once for each element of a vector or list. The for keyword creates a for-loop. Here’s the syntax: for (I in DATA) { # Your code goes here } The variable I is called the induction variable. At the beginning of each iteration, I is assigned the next element of the vector or list DATA. The loop iterates once for each element of DATA, unless you use a keyword to exit the loop early (more about this in Section 4.1.4). As with if-statements and functions, the curly braces { } are only required if the body contains multiple lines of code. Unlike the other iteration strategies, loops do not automatically return a result. You have complete control over the output, which means that anything you want to save must be assigned to a variable. For example, let’s make a loop that repeatedly adds a number to a running total and squares the new total. We’ll use a variable total to keep track of the running total as the loop iterates: numbers = c(-1, 1, -3, 2) total = 0 for (number in numbers) { total = (total + number)^2 } total ## [1] 9 Use for-loops when some or all of the iterations depend on results from other iterations. If the iterations are not dependent, use one of: Vectorization (because it’s faster) Apply functions (because they’re idiomatic) In some cases, you can use vectorization even when the iterations are dependent. For example, you can use vectorization to compute the sum of the cubes of several numbers: sum(numbers^3) ## [1] -19 4.1.2 While-loops A while-loop runs a block of code repeatedly as long as some condition is TRUE. The while keyword creates a while-loop. Here’s the syntax: while (CONDITION) { # Your code goes here } The CONDITION should be a scalar logical value or an expression that returns one. At the beginning of each iteration, CONDITION is checked, and the loop exits if it is FALSE. As always, the curly braces { } are only required if the body contains multiple lines of code. For example, suppose you want to add up numbers from 0 to 50, but stop as soon as the total is greater than 50: num50 = seq(0, 50) total = 0 i = 1 while (total &lt; 50) { total = total + num50[i] message(&quot;i is &quot;, i, &quot; total is &quot;, total) i = i + 1 } ## i is 1 total is 0 ## i is 2 total is 1 ## i is 3 total is 3 ## i is 4 total is 6 ## i is 5 total is 10 ## i is 6 total is 15 ## i is 7 total is 21 ## i is 8 total is 28 ## i is 9 total is 36 ## i is 10 total is 45 ## i is 11 total is 55 total ## [1] 55 i ## [1] 12 While-loops are a generalization of for-loops. They tend to be most useful when you don’t know how many iterations will be necessary. For example, suppose you want to repeat a computation until the result falls within some range of values. 4.1.3 Saving Multiple Results Loops often produce a different result for each iteration. If you want to save more than one result, there are a few things you must do. First, set up an index vector. The index vector should usually be congruent to the number of iterations or the input. The seq_along function returns a congruent index vector when passed a vector or list. For instance, let’s make in index for the numbers vector from Section 4.1.1: index = seq_along(numbers) The loop will iterate over the index rather than the input, so the induction variable will track the current iteration number. On the first iteration, the induction variable will be 1, on the second it will be 2, and so on. Then you can use the induction variable and indexing to get the input for each iteration. Second, set up an empty output vector or list. This should usually be congruent to the input, or one element longer (the extra element comes from the initial value). R has several functions for creating vectors. We’ve already seen a few, but here are more: logical, integer, numeric, complex, and character to create an empty vector with a specific type and length vector to create an empty vector with a specific type and length rep to create a vector by repeating elements of some other vector Empty vectors are filled with FALSE, 0, or \"\", depending on the type of the vector. Here are some examples: logical(3) ## [1] FALSE FALSE FALSE numeric(4) ## [1] 0 0 0 0 rep(c(1, 2), 2) ## [1] 1 2 1 2 Let’s create an empty numeric vector congruent to numbers: n = length(numbers) result = numeric(n) As with the input, you can use the induction variable and indexing to set the output for each iteration. Creating a vector or list in advance to store something, as we’ve just done, is called preallocation. Preallocation is extremely important for efficiency in loops. Avoid the temptation to use c or append to build up the output bit by bit in each iteration. Finally, write the loop, making sure to get the input and set the output. Here’s the loop for the squared sums example: for (i in index) { prev = if (i &gt; 1) result[i - 1] else 0 result[i] = (numbers[i] + prev)^2 } result ## [1] 1 4 1 9 4.1.4 Break &amp; Next The break keyword causes a loop to immediately exit. It only makes sense to use break inside of an if-statement. For example, suppose we want to print each string in a vector, but stop at the first missing value. We can do this with break: my_messages = c(&quot;Hi&quot;, &quot;Hello&quot;, NA, &quot;Goodbye&quot;) for (msg in my_messages) { if (is.na(msg)) break message(msg) } ## Hi ## Hello The next keyword causes a loop to immediately go to the next iteration. As with break, it only makes sense to use next inside of an if-statement. Let’s modify the previous example so that missing values are skipped, but don’t cause printing to stop. Here’s the code: for (msg in my_messages) { if (is.na(msg)) next message(msg) } ## Hi ## Hello ## Goodbye These keywords work with both for-loops and while-loops. 4.1.5 Example: The Collatz Conjecture The Collatz Conjecture is a conjecture in math that was introduced in 1937 by Lothar Collatz and remains unproven today, despite being relatively easy to explain. Here’s a statement of the conjecture: Start from any positive integer. If the integer is even, divide by 2. If the integer is odd, multiply by 3 and add 1. If the result is not 1, repeat using the result as the new starting value. The result will always reach 1 eventually, regardless of the starting value. The sequences of numbers this process generates are called Collatz sequences. For instance, the Collatz sequence starting from 2 is 2, 1. The Collatz sequence starting from 12 is 12, 6, 3, 10, 5, 16, 8, 4, 2, 1. As a final loop example, let’s use a while-loop to compute Collatz sequences. Here’s the code: n = 5 i = 0 while (n != 1) { i = i + 1 if (n %% 2 == 0) { n = n / 2 } else { n = 3 * n + 1 } message(paste0(n, &quot; &quot;)) } ## 16 ## 8 ## 4 ## 2 ## 1 As of 2020, scientists have used computers to check the Collatz sequences for every number up to approximately \\(2^{64}\\). For more details about the Collatz Conjecture, check out this video. 4.2 Planning for Iteration At first it may seem difficult to decide if and what kind of iteration to use. Start by thinking about whether you need to do something over and over. If you don’t, then you probably don’t need to use iteration. If you do, then try iteration strategies in this order: vectorization apply functions Try an apply function if iterations are independent. for/while-loops Try a for-loop if some iterations depend on others. Try a while-loop if the number of iterations is unknown. recursion (which isn’t covered here) Convenient for naturally recursive problems (like Fibonacci), but often there are faster solutions. Start by writing the code for just one iteration. Make sure that code works; it’s easy to test code for one iteration. When you have one iteration working, then try using the code with an iteration strategy (you will have to make some small changes). If it doesn’t work, try to figure out which iteration is causing the problem. One way to do this is to use message to print out information. Then try to write the code for the broken iteration, get that iteration working, and repeat this whole process. "],["assessment.html", "Assessment", " Assessment If you are taking this workshop to complete a GradPathways Pathway, you can download the assessment instructions here. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
